---
title: 数据结构之逆波兰式
copyright: true
date: 2019-08-17 20:40:35
tags:
	- 逆波兰式
	- 堆栈
	- 中缀表达式
categories:
	- 数据结构
top: false
---

学的数据结构，感觉掌握的不牢固，于是实现了一个demo
# 中缀表达式转换为后缀表达式并求值
 1. 算法思想:
创建一个操作数栈，自左向右遍历后缀表达式，遇到一个操作数就入栈，
遇到一个操作符就从栈中取出两个操作数进行当前计算，载把结果入栈，
直到表达式末尾, 最后一个入栈的就是最终结果
 2. 先实现求值这一步吧，已知后缀表达式 
 3. 转换这一环节待更新...

# 源代码
```
			#include <stdio.h>
			#include <stdlib.h>

			#define maxsize 100
			#define datatype int

			typedef struct {
				datatype data[maxsize];
				int top;		// top 指明当前栈顶元素的位置
			} SeqStack, *PSeqStack;


			// 初始化顺序栈
			PSeqStack Init_SeqStack(){
				PSeqStack S;
				S = (PSeqStack) malloc(sizeof(SeqStack));
				//printf("%p\n", S);

				if (S)
					S -> top = -1;		// top 设为-1 (认为设定),表示空
				return S;		// 返回指向顺序栈的指针
			}

			// 判断栈空
			int Empty_SeqStack(PSeqStack S){
				// 没有元素，空栈
				if (S -> top == -1)	
					return 1;		// 1 表示为空
	
				return 0;
	
			}

			// 入栈
			void Push_SeqStack(PSeqStack S, datatype x){
				if (S -> top == maxsize-1){
					printf("栈满不能再入栈\n");
					//return 0;		// 返回 0 表示失败
				}
				else{
					S -> top ++;
					S -> data[S -> top] = x;
		
					//return 1;
				}
			}

			// 出栈,保存栈顶元素于*x中，并删除
			void Pop_SeqStack(PSeqStack S, datatype *x){
				if (Empty_SeqStack(S)){
					printf("栈空不能出栈\n");
					//return 0;		// 0 表示出栈失败
				}
				else{
					*x = S -> data[S -> top];
					S -> top --;
		
		
					//return 1;
				}
			}

			// 取栈顶元素，只是获取他的值并存入*x，并没有取出来(删除),注意区别
			int GetTop_SeqStack(PSeqStack S, datatype *x){
				if (Empty_SeqStack(S)){
					printf("栈空不能取top元素\n");
					return 0;
				}
	
				else{
					*x = S -> data[S -> top];
					return 1;
				}
			}

			// 销毁栈，参数为待销毁顺序栈的指针地址
			void Destory_SeqStack(PSeqStack *S){
				// *S 二级指针
				if (*S)
					free (*S);
	
				*S = NULL;
				return;
			}


			/*　判断是否是操作数　*/
			int IsNum(char c){
				if (c >= '0' && c <= '9'){
					return 1;
				}

				return 0;
			}

			char transfer(){
		
			}

			/* 核心函数　*/
			int calculate(char *A){
				PSeqStack s = Init_SeqStack();
				int result;
				int a, b, c;    // a,b 上一次，上上一次入栈的元素，Ｃ是临时变量
				char ch;
		
				ch = *A ++;

				/* 我们人为设置，在字符数组末尾加一个'#', 作为结束符　*/
				while(ch != '#'){
					if (IsNum(ch)){
						Push_SeqStack(s, ch - '0');
					}
				
					else
					{
						/* 这里注意，　先进后出　*/
						Pop_SeqStack(s, &b);
						Pop_SeqStack(s, &a);

						switch (ch)
						{
						    case '+':
						        c = a+b;
						        break;
						    case '-':
						        c = a-b;
						        break;
						    case '*':
						        c = a*b;
						        break;
						    case '/':
						        c = a/b;
						        break;
						    default:
						        break;
						}

						/* 临时结果入栈　*/
						Push_SeqStack(s, c);
					}

					ch = *A ++;      
				}
		
				GetTop_SeqStack(s, &result);
				Destory_SeqStack(&s);
				return result;
			}

			int main(){
				char num[12] = {'1','2','8','5','-','*','+','4','2','/','-', '#'};

				printf("计算结果: %d\n",calculate(num));  

				return 0;
			}
```

测试输入:
```
char num[12] = {'1','2','8','5','-','*','+','4','2','/','-', '#'};
```

测试结果:
```
5
```

# 写在最后
其实，习惯了用C++的STL容器，我在平时的coding中很少会自己去创建一些数据结构，要排序会有*std::sort()*函数，而且STL容器的算法复杂度要远比单一数据结构算法复杂度要小的多，就拿排序来说，他用的可不止一种排序算法，不信这个有时间咱们可以验证...
我学数据结构最大的收获就是：
+ 学会用计算机的思维去思考问题
+ 学会如何调试程序
+ 学会耐心做一件事[课程设计]()

