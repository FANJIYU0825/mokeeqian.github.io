<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解C函数调用机制]]></title>
    <url>%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6.html</url>
    <content type="text"><![CDATA[写在前面C语言是面向过程的一种语言，而函数则作为解决一个个问题的“过程”，在一个程序中，会出现函数的声明、定义以及调用，我们已经知道C函数的调用和栈有关，但是在有些程序的debug过程中，如果不了解函数调用的底层实现原理，是很痛苦的。所以这里就以x86-64下的C语言函数调用为例，至于为什么不带上C++，前面已经说过，C++ is not greater C，C++里面的构造函数、虚函数，更为复杂，所以这里不做讨论。在此之前，需要了解一下： 栈帧栈帧也叫过程活动记录，可以说每个函数的调用都对应着一个栈帧，栈帧里保存了函数运行的环境：函数参数、返回地址(下一条指令的地址)、局部变量等。要知道，栈的存储顺序是从高地址往低地址存储，每个函数的每次调用，都会有属于自己的栈帧，ebp(32位)/rbp(64位)叫做栈底指针寄存器，指向栈帧的底部(高地址)；esp/rsp指向栈帧顶部(低地址) x86-64下16个通用寄存器 每个寄存器的用途并不是单一的。 %rax 通常用于存储函数调用的返回结果，同时也用于乘法和除法指令中。在imul 指令中，两个64位的乘法最多会产生128位的结果，需要 %rax 与 %rdx 共同存储乘法结果，在div 指令中被除数是128 位的，同样需要%rax 与 %rdx 共同存储被除数。 %rsp 是堆栈指针寄存器，通常会指向栈顶位置，堆栈的 pop 和push 操作就是通过改变 %rsp 的值即移动堆栈指针的位置来实现的。 %rbp 是栈帧指针，用于标识当前栈帧的起始位置 %rdi, %rsi, %rdx, %rcx,%r8, %r9 六个寄存器用于存储函数调用时的6个参数（如果有6个或6个以上参数的话）。 被标识为 “miscellaneous registers” 的寄存器，属于通用性更为广泛的寄存器，编译器或汇编程序可以根据需要存储任何数据。 这里还要区分一下 “Caller Save” 和 ”Callee Save” 寄存器，即寄存器的值是由”调用者保存“ 还是由 ”被调用者保存“。当产生函数调用时，子函数内通常也会使用到通用寄存器，那么这些寄存器中之前保存的调用者(父函数）的值就会被覆盖。为了避免数据覆盖而导致从子函数返回时寄存器中的数据不可恢复，CPU 体系结构中就规定了通用寄存器的保存方式。如果一个寄存器被标识为”Caller Save”， 那么在进行子函数调用前，就需要由调用者提前保存好这些寄存器的值，保存方法通常是把寄存器的值压入堆栈中，调用者保存完成后，在被调用者（子函数）中就可以随意覆盖这些寄存器的值了。如果一个寄存被标识为“Callee Save”，那么在函数调用时，调用者就不必保存这些寄存器的值而直接进行子函数调用，进入子函数后，子函数在覆盖这些寄存器之前，需要先保存这些寄存器的值，即这些寄存器的值是由被调用者来保存和恢复的。 函数调用函数调用时，caller与callee的栈帧结构如图：子函数调用时，执行的操作： 父函数将调用参数从后向前压栈 将返回地址压栈保存 跳转到子函数起始地址执行 子函数将父函数栈帧起始地址（%rpb） 压栈 将 %rbp 的值设置为当前 %rsp 的值，即将 %rbp 指向子函数栈帧的起始地址 示例代码：testfun.c 123456789void fun(int a, int b, int c) &#123; int x = 10; int y = 100;&#125;int main() &#123; fun(1,2,3); return 0;&#125; gcc进行编译： 1$ gcc testfun.c -g -o testfun gcc生成汇编代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 .file "testfun.c" .text .globl fun .type fun, @functionfun:.LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl %edi, -20(%rbp) movl %esi, -24(%rbp) movl %edx, -28(%rbp) movl $10, -8(%rbp) movl $100, -4(%rbp) nop popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc.LFE0: .size fun, .-fun .globl main .type main, @functionmain:.LFB1: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $3, %edx movl $2, %esi movl $1, %edi call fun movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc.LFE1: .size main, .-main .ident "GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.11) 5.4.0 20160609" .section .note.GNU-stack,"",@progbits 貌似不大好看，使用objdump反汇编看看(只保留关键代码)： 123456789101112131415161718192021222324252627282930313233343536testfun: file format elf64-x86-6400000000004004d6 &lt;fun&gt;:void fun(int a, int b, int c) &#123; 4004d6: 55 push %rbp 4004d7: 48 89 e5 mov %rsp,%rbp 4004da: 89 7d ec mov %edi,-0x14(%rbp) 4004dd: 89 75 e8 mov %esi,-0x18(%rbp) 4004e0: 89 55 e4 mov %edx,-0x1c(%rbp) int x = 10; 4004e3: c7 45 f8 0a 00 00 00 movl $0xa,-0x8(%rbp) int y = 100; 4004ea: c7 45 fc 64 00 00 00 movl $0x64,-0x4(%rbp)&#125; 4004f1: 90 nop 4004f2: 5d pop %rbp 4004f3: c3 retq 00000000004004f4 &lt;main&gt;:int main() &#123; 4004f4: 55 push %rbp 4004f5: 48 89 e5 mov %rsp,%rbp fun(1,2,3); // 对fun(int, int, int)的调用 4004f8: ba 03 00 00 00 mov $0x3,%edx // 3先入栈 4004fd: be 02 00 00 00 mov $0x2,%esi // 然后是2 400502: bf 01 00 00 00 mov $0x1,%ed // 最后是1 400507: e8 ca ff ff ff callq 4004d6 &lt;fun&gt; return 0; 40050c: b8 00 00 00 00 mov $0x0,%eax&#125; 400511: 5d pop %rbp 400512: c3 retq 400513: 66 2e 0f 1f 84 00 00 nopw %cs:0x0(%rax,%rax,1) 40051a: 00 00 00 40051d: 0f 1f 00 nopl (%rax) 这个就好看多了，有对应的汇编代码和C源码，对于我这个汇编菜鸟来说真是太人性化了。不过这还是不够，我们还有寄存器没有观察。万能的gdb，这件事就交给你了。 1$ gdb testfun -tui // 使用tui界面 接着， 1$ layout regs // 分配一个寄存器界面布局 然后， 1set disassmele-next-line on // 实时显示反汇编代码 接着，在fun()的调用位置打上断点， 12$ b 7 //也就是我们的fun(1,2,3);$ b *fun // 注意 *fun是汇编级别的fun()函数地址 接着，单步运行， 12$ ni // 注意,ni和si都是相对于汇编代码的单步运行，n和s只是相对于C代码的单步运行； // 再者，n和s都有单步运行的功能，只不过s直接会进入函数调用的内部 1. main 首先，3进入%edx寄存器然后,2进入%esi寄存器接着，1进入%edi寄存器然后对fun()函数进行调用 1234 0x00000000004004f8 &lt;main+4&gt;: ba 03 00 00 00 mov $0x3,%edx 0x00000000004004fd &lt;main+9&gt;: be 02 00 00 00 mov $0x2,%esi 0x0000000000400502 &lt;main+14&gt;: bf 01 00 00 00 mov $0x1,%edi=&gt; 0x0000000000400507 &lt;main+19&gt;: e8 ca ff ff ff callq 0x4004d6 &lt;fun&gt; 2. fun 12345678=&gt; 0x00000000004004d6 &lt;fun+0&gt;: 55 push %rbp 0x00000000004004d7 &lt;fun+1&gt;: 48 89 e5 mov %rsp,%rbp 0x00000000004004da &lt;fun+4&gt;: 89 7d ec mov %edi,-0x14(%rbp) 0x00000000004004dd &lt;fun+7&gt;: 89 75 e8 mov %esi,-0x18(%rbp) 0x00000000004004e0 &lt;fun+10&gt;: 89 55 e4 mov %edx,-0x1c(%rbp) 0x00000000004004f1 &lt;fun+27&gt;: 90 nop 0x00000000004004f2 &lt;fun+28&gt;: 5d pop %rbp 0x00000000004004f3 &lt;fun+29&gt;: c3 retq]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>函数调用</tag>
        <tag>栈帧</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程与进程]]></title>
    <url>%2F%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B.html</url>
    <content type="text"><![CDATA[计算机系统中的进程与线程参考这篇文章 写在前面 进程和线程都是一个对cpu工作的时间段的描述 进程是资源分配的最小单位，线程是cpu调度的最小单位 进程是线程的爸爸(开玩笑的比喻) 要知道的知识 cpu的运算和执行速度很快、非常快，就连寄存器也只能勉强追上cpu的车尾灯，至于内存以及其他存储设备，是远远追不上cpu的处理速度的 计算机很笨，cpu在同一时间段只能做一件事情，我们平时的一边码代码，一边开网易云音乐，其实是cpu不断在这两个客户端软件之间来回切换，只不过切换的速度太快了，以至于我们以为cpu是同时运行的 计算机执行程序的过程，轮流执行，加载程序A的上下文，执行程序A，保存程序A的上下文；加载程序B的上下文，执行程序B，保存程序B的上下文；…… 介绍进程进程是资源分配的最小单位，貌似有点抽象，就来打个比方吧。我们开了一个word，开了一个qq音乐和一个网易云音乐，那么我们的计算机中就有了三个进程(假使不存在其他的程序，假使)，那么下图就是我们的cpu运行这三个程序的情况：每个小方格都是一个cpu运行的时间片段，约100ms，cpu就是这样不断地在这些程序之间来回切换，由于时间间隔太短，所以造成了多个程序“并行运行”的假象。其实不然，这是早些年在单核cpu上出现的技术，所以说，当运行的程序过多，cpu负载越大，切换的时间也就越长，所以我们会感觉到明显的卡顿现象。于是乎，多核cpu出现了。 线程可以说，线程是进程的儿子，一个进程可以拥有多个线程，这些线程会共享cpu为进程分配的资源，就好像多个儿子共享父亲的财产。以qq为例，我们打开了qq，我们一边聊天，一边发图片，一边发文件，一边刷新qq消息，这些都是在我们的qq程序里面实现的，也就是说，我们做的这四个工作，都是在qq这个进程之下。 区别及联系联系： 一个线程只会属于一个进程，但一个进程至少会有一个线程 资源分配给进程，这些资源会被它下面的线程共享 线程在执行过程中，需要同步协作，不同进程的线程需要依靠消息通信来实现协作 区别： 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源. 系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++之sizeof与strlen]]></title>
    <url>%2FC%2B%2B%E4%B9%8Bsizeof%E4%B8%8Estrlen.html</url>
    <content type="text"><![CDATA[C/C++中的sizeof与strlen很久之前的C课程上面老师就提到过sizeof，当时也不知道是怎么一回事，后来在读代码的过程中经常遇到sizeof，索性就来好好了解一下吧。 区别sizeof首先要知道一点，sizeof是C/C++中的一个运算符，我们通常的用法是sizeof(foo)，在编译时才会计算foo的大小并返回，它的值不受foo里面所存储的内容影响，只会和foo的数据类型(char还是int还是指针…)和计算机平台(32位还是64位)有关。 举个例子：Test1.cpp 1234567891011#include &lt;iostream&gt;using namespace std;int main() &#123; int a; char b; int *c; cout &lt;&lt; sizeof(a) &lt;&lt; endl; // int 类型占4个字节 cout &lt;&lt; sizeof(b) &lt;&lt; endl; // char 类型占1个字节 cout &lt;&lt; sizeof(c) &lt;&lt; endl; // 64位系统指针占8个字节，32位一个指针占4个字节 return 0;&#125; 测试输出： 123418 **Test2.cpp** 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; int a = 1; int d = 10; char b; int *c; double *e; cout &lt;&lt; sizeof(a) &lt;&lt; endl; // 4 cout &lt;&lt; sizeof(b) &lt;&lt; endl; cout &lt;&lt; sizeof(c) &lt;&lt; endl; cout &lt;&lt; sizeof(d) &lt;&lt; endl; // 4 cout &lt;&lt; sizeof(e) &lt;&lt; endl; return 0;&#125; 测试输出： 1234541848 sizeof(a)和sizeof(d)相等，这就说明了sizeof(foo)与foo里面存取的内容无关。 好接下来，如果遇到C++中的类怎么办？ **Test3.cpp** 1234567891011121314#include &lt;iostream&gt;using namespace std;class Foo &#123; int a; // 4 char b; // 1 int *c; // 8&#125;;int main() &#123; Foo foo; cout &lt;&lt; sizeof(foo) &lt;&lt; endl; return 0;&#125; 测试结果： 116 啥？输出是16，为什么是16呢？4+1+8不应该是13吗？一开始我也是这么认为的，知道看了inside the C++ object module一书时才醒悟，我们的编译器一般都会对我们的代码做出优化，一个专业名词叫做内存对齐，编译器在编译程序时，会检测一个类的数据成员，是否sizeof(foo)的值是4的整数倍，如果不是，就会自动扩张成4的整数倍(距离当期sizeof最小的)，具体为什么，要说到C++中的成员数据的内部布局，这个我们在这先不做讨论。大家记着就好，后面我会详细介绍。所以说，上面的答案就合乎逻辑了，16 = 4 + 1 + 8 + 3，这个3叫做padding size。 不妨再来一波？Test4.cpp 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;class Foo &#123; int a; // 4 char b; // 1 int *c; // 8&#125;;class Bar:public Foo &#123; // 加上继承试试 char d; // 1&#125;;int main() &#123; Foo foo; Bar bar; cout &lt;&lt; "sizeof foo is: " &lt;&lt; sizeof(foo) &lt;&lt; endl; // 16 cout &lt;&lt; "sizeof bar is: " &lt;&lt; sizeof(bar) &lt;&lt; endl; // 24 return 0;&#125; 测试结果： 12sizeof foo is: 16sizeof bar is: 24 //why??? 是不是又蒙了？加上继承之后，sizeof(bar)为什么是24呢？先抛砖引玉，后面的文章再详细解释。 strlenstrlen()是C的一个库函数，注意它是函数，一般用于计算字符串的长度，遇到&#39;\0&#39;就停止计算。我们来测试一下：Test5.cpp 12345678910111213141516#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main() &#123; char *a = "Hello World"; char b[100] = "Hello World"; char c[] = "Hello World"; cout &lt;&lt; "sizeof a is: " &lt;&lt; sizeof(a) &lt;&lt; endl; cout &lt;&lt; "strlen a is: " &lt;&lt; strlen(a) &lt;&lt; endl; cout &lt;&lt; "sizeof b is: " &lt;&lt; sizeof(b) &lt;&lt; endl; cout &lt;&lt; "strlen b is: " &lt;&lt; strlen(b) &lt;&lt; endl; cout &lt;&lt; "sizeof c is: " &lt;&lt; sizeof(c) &lt;&lt; endl; cout &lt;&lt; "strlen c is: " &lt;&lt; strlen(c) &lt;&lt; endl; return 0;&#125; 测试结果： 123456sizeof a is: 8 // 一个指针大小strlen a is: 11 // 字符串长度，不带'\0'sizeof b is: 100 // 数组大小strlen b is: 11 // 字符串长度，不带'\0'sizeof c is: 12 // 字符串长度，加上一个'\0'strlen c is: 11 // 字符串长度，不带'\0' 补充说明讲到这里，二者之间的区别想必大家也都明白了，strlen 的结果要在运行的时候才能计算出来，而sizeof的值是在编译时就确定的，所以不能用sizeof来计算动态分配的类型大小。 Test6.cpp 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main() &#123; char *a = new char[20]; cout &lt;&lt; "sizeof a is: " &lt;&lt; sizeof(a) &lt;&lt; endl; // 8 cout &lt;&lt; "strlen a is: " &lt;&lt; strlen(a) &lt;&lt; endl; // 0 cout &lt;&lt; "sizeof *a is: " &lt;&lt; sizeof(*a) &lt;&lt; endl; // 1 *a = 'a'; cout &lt;&lt; "now sizeof a is: " &lt;&lt; sizeof(a) &lt;&lt; endl; // 8 cout &lt;&lt; "now strlen a is: " &lt;&lt; strlen(a) &lt;&lt; endl; // 1 cout &lt;&lt; "now sizeof *a is: " &lt;&lt; sizeof(*a) &lt;&lt; endl; // 1 delete[] a; a = NULL; return 0;&#125; 测试结果： 123456sizeof a is: 8strlen a is: 0sizeof *a is: 1now sizeof a is: 8now strlen a is: 1now sizeof *a is: 1 // sizeof(*a)没变化??]]></content>
      <categories>
        <category>C++</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>sizeof</tag>
        <tag>strlen</tag>
        <tag>内存对齐</tag>
        <tag>C++成员布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python--记一次爬虫经历]]></title>
    <url>%2FPython--%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%88%AC%E8%99%AB%E7%BB%8F%E5%8E%86.html</url>
    <content type="text"><![CDATA[记一次Python爬虫经历 这几天，老师让我写一个爬虫，抓取正方教务系统的数据，想想自己很久没有搞Python了，于是答应了，刚好自己之前有过这样的想法，爬一爬教务处的网站，以后查信息什么的就方便多了。 其实自己之前写过的爬虫都是静态网站的，直接get请求一下，解析相应的网页内容就能实现了，但是这次做的是动态网站，需要提交验证码，好在观察了一下，验证码只是简单的数字验证码，没有像铁总的12306那样反人类的验证码。话不多说，开干。 实现过程登录实现上图中的表单正是我们登录系统的，获取它的id，然后我们人为把我们的登录信息传递给这些id，我们再来看看请求头，请求方式是post，也就是说，我们要把headers、cookies、data这些参数一起post到web服务器上。 下面的这是我们的用户信息，也就是浏览器中的输入框和选择按钮，其中__VIEWSTATE这个属性好像是sessionId？我尝试了一下不带这个参数进行post，结果没有登录成功。咱也不知道，赞只管用就行了。来说明一下：TextBox1是用户名TextBox2是用户密码TextBox3是验证码RadioButtonList1是用户身份，我们默认的学生就好Button1是登录按钮 等等，是不是忘了什么重要的事情？验证码呢？这是验证码所在的url，我们等下可以get一下，抓取网页内容，然后将验证码保存下来。 查询实现查询功能就比较容易实现了，只要我们获取到了cookies就可以了，然后每次进行不同的查询时，只要更新一下headers中的__VIEWSTATE属性的值就可以了，然后抓取相应的网页内容，进行信息的提取，可以发现，我们的信息主要都是表格布局，所以简单来说只要用正则匹配一下就可以简单获取信息了。 代码实现1. config_loader.py 1234567891011121314151617181920212223242526#!/usr/bin/env python3# encoding=utf-8# Copyright: Qian Jipeng(C) 2019import configparsercf = configparser.ConfigParser()cf.read("config.conf")section = cf.sections() # a list#print(section)#print(cf.options('user'))def getUserId(): return str(cf.get('user', 'userid'))def getUserPassword(): return str(cf.get('user', 'password'))def getIndexUrl(): return str(cf.get('web', 'index'))def getLoginUrl(): return str(cf.get('web', 'loginurl'))def getCheckcodeUrl(): return str(cf.get('web', 'checkcodeurl')) 2. main.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381#!/usr/bin/env python3# encoding=utf-8# Copyright: Qian Jipeng(C) 2019"""TODO: 数据清洗与进一步解析!"""import osimport reimport urllib.parseimport requestsimport config_loader as cflfrom html.parser import *from PIL import Imageclass TagParser(HTMLParser): # view_state = list() # 有点像C++中的static变量，是类变量，不可行 def __init__(self): super().__init__() self.view_state = list() # 用来存放viewstate def __del__(self): del self.view_state # 释放资源 def handle_starttag(self, tag, attrs): if tag == 'input': attrs = dict(attrs) if attrs.__contains__('name') and attrs['name'] == '__VIEWSTATE': self.view_state.append(attrs['value']) def doParse(self, webData): self.feed(data=webData)class Login: def __init__(self): self.user_id = cfl.getUserId() self.user_pwd = cfl.getUserPassword() self.user_name = "" self.login_url = cfl.getLoginUrl() self.checkcode_url = cfl.getCheckcodeUrl() self.cookies = requests.get(self.login_url).cookies self.headers = &#123; 'User-Agent': r'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36', &#125; # self.query_headers = &#123; # 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3', # 'Accept-Encoding': 'gzip, deflate', # 'Accept-Language': 'en-US,en;q=0.9', # 'Connection': 'keep-alive', # 'Content-Type': 'text/html; charset=gb2312', # 'Referer': '', # cfl.getIndexUrl() + 'xskbcx.aspx?xh=' + self.user_id + "&amp;xm=" + self.user_name + "&amp;gnmkdm=" + kdn_code, # # 'Referer': website + 'xs_main.aspx?xh=' + userxh, # 'Upgrade-Insecure-Requests': '1', # 'User-Agent': r'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36', # &#125; self.config = &#123; '__VIEWSTATE': '', # viewstate 'TextBox1': self.user_id, # userid 'TextBox2': self.user_pwd, # password 'TextBox3': '', # checkcode 'RadioButtonList1': '%D1%A7%C9%FA', # session 'Button1': "", 'lbLanguage': '', &#125; self.tag_parser = TagParser() self.tag_parser.doParse(requests.get(self.login_url).text) # 解析 # 获取验证码并显示 def getCheckCodePic(self, filename): pic = requests.post(url=self.checkcode_url, cookies=self.cookies, headers=self.headers) if os.path.exists(filename): os.remove(filename) # write as byte with open(filename, 'wb') as filewriter: filewriter.write(pic.content) image = Image.open(filename) # PIL image.show() # # 更新headers字典，在查询之前，必须先调用该函数 # def updateQueryHeaders(self, referer): # self.query_headers['Referer'] = referer # 应该在获取验证码后调用 def updateConfig(self, viewstate, checkcode): self.config['__VIEWSTATE'] = viewstate self.config['TextBox3'] = checkcode # 是否登陆成功 def checkIfSuccess(self, webContent): pattern = r'&lt;title&gt;(.*?)&lt;/title&gt;' items = re.findall(pattern, webContent.text) if items[0] == "欢迎使用正方教务管理系统！请登录": # 特征匹配 # print("登陆失败") return False else: # print("登陆成功") # 抓取名字 catch = '&lt;span id="xhxm"&gt;(.*?)&lt;/span&gt;&lt;/em&gt;' name = re.findall(catch, webContent.text) name = name[0][:-2] # name = name[:-2] print(name) self.user_name = urllib.parse.quote(name.encode("gb2312")) # 更新用户姓名 return True# # Not used# class Query(Login):## def __init__(self):# Login.__init__(self)# self.course_url = cfl.getIndexUrl() + "xskbcx.aspx?xh=" + self.user_id + "&amp;xm=" + self.user_name + "&amp;gnmkdm=" + "N121603"# self.exam_url = cfl.getIndexUrl() + "xskscx.aspx?xh=" + self.user_id + "&amp;xm=" + self.user_name + "&amp;gnmkdm=" + "N121604"# self.query_state = ""# self.query_config = &#123;# '__EVENTTARGET': '',# '__EVENTARGUMENT': '',# '__VIEWSTATE': '',# &#125;# self.query_headers = &#123;# 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3',# 'Accept-Encoding': 'gzip, deflate',# 'Accept-Language': 'en-US,en;q=0.9',# 'Connection': 'keep-alive',# 'Content-Type': 'text/html; charset=gb2312',# #'Referer': '',# # cfl.getIndexUrl() + 'xskbcx.aspx?xh=' + self.user_id + "&amp;xm=" + self.user_name + "&amp;gnmkdm=" + kdn_code,# 'Upgrade-Insecure-Requests': '1',# 'User-Agent': r'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36',# &#125;## def updateQueryConfig(self, queryviewstate):# self.query_config['__VIEWSTATE'] = queryviewstate## def updateQueryHeaders(self, referer):# self.query_headers['Referfer'] = referer## def updateQueryState(self):# content = requests.get(url=self.course_url, cookies=self.cookies, headers=self.headers)# print(content.text)# catch = '&lt;input type="hidden" name="__VIEWSTATE" value="(.*?)" /&gt;'# self.query_state = re.findall(catch, content.text)[0]## # 课表查询# def queryCourse(self):# # 先配置headers# self.updateQueryHeaders(self.course_url)## # print(self.query_headers)## self.updateQueryState()# self.updateQueryConfig(self.query_state)# print("config")# print(self.query_config)# content = requests.session().get(url=self.course_url, data=self.query_config,# headers=self.query_headers, cookies=super().cookies)# # 保存表格# catch = '&lt;td&gt;(.*?)&lt;/td&gt;'# table = re.findall(catch, content.text)## f = open("test.txt", "w")# for each_line in table:# if "&amp;nbsp" in each_line:# # TODO: 数据清洗# pass# f.write(each_line + "\n")# f.close()# 全局函数，对外接口def doLogin(loginobject:Login, filename:str): loginobject.getCheckCodePic(filename) checkcode = input("输入验证码: ") loginobject.updateConfig(loginobject.tag_parser.view_state[0], checkcode) # print(loginobject.config) content = requests.post(url=loginobject.login_url, data=loginobject.config, headers=loginobject.headers, cookies=loginobject.cookies) if loginobject.checkIfSuccess(content): print("登陆成功!!!") else: print("登录失败~~~") # query = Query() # query.queryCourse() print("-------------开始查询----------------") # 配置区 course_url = cfl.getIndexUrl() + 'xskbcx.aspx?xh=' + loginobject.user_id + "&amp;xm=" + loginobject.user_name + "&amp;gnmkdm=" + "N121603" exam_url = cfl.getIndexUrl() + 'xskscx.aspx?xh=' + loginobject.user_id + "&amp;xm=" + loginobject.user_name + "&amp;gnmkdm=" + "N121604" classexam_url = cfl.getIndexUrl() + 'xsdjkscx.aspx?xh=' + loginobject.user_id + "&amp;xm=" + loginobject.user_name + "&amp;gnmkdm=" + "N121606" plan_url = cfl.getIndexUrl() + 'pyjh.aspx?xh=' + loginobject.user_id + "&amp;xm=" + loginobject.user_name + "&amp;gnmkdm=" + "N121607" select_course_url = cfl.getIndexUrl() + 'pyjh.aspx?xh=' + loginobject.user_id + "&amp;xm=" + loginobject.user_name + "&amp;gnmkdm=" + "N121615" add_exam_url = cfl.getIndexUrl() + 'xsbkkscx.aspx?xh=' + loginobject.user_id + "&amp;xm=" + loginobject.user_name + "&amp;gnmkdm=" + "N121613" query_config = &#123; '__EVENTTARGET': '', '__EVENTARGUMENT': '', '__VIEWSTATE': '', &#125; query_headers = &#123; 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'en-US,en;q=0.9', 'Connection': 'keep-alive', 'Content-Type': 'text/html; charset=gb2312', 'Referer': '', 'Upgrade-Insecure-Requests': '1', 'User-Agent': r'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'&#125; # end 配置区 # ------------------------- 查询课表 ---------------------- query_headers['Referer'] = course_url # 先get一下，获取view_state course_html = requests.get(course_url, cookies=loginobject.cookies, headers=query_headers) catch = '&lt;input type="hidden" name="__VIEWSTATE" value="(.*?)" /&gt;' query_state = re.findall(catch, course_html.text)[0] query_config['__VIEWSTATE'] = query_state del query_state course = requests.session().get(url=course_url, data=query_config, headers=query_headers, cookies=loginobject.cookies) # print(course.text) # 测试ok # 写入文件 catch = '&lt;td&gt;(.*?)&lt;/td&gt;' course_table = re.findall(catch, course.text) del course f = open("course_table.txt", "w") for each_line in course_table: if "&amp;nbsp" in each_line: # TODO: 数据清洗 pass f.write(each_line + "\n") f.close() del course_table # ------------------------- 课表结束 ------------------------ # ------------------------- 查询考试安排 ----------------------- query_headers['Referer'] = exam_url exam_html = requests.get(exam_url, cookies=loginobject.cookies, headers=query_headers) catch = '&lt;input type="hidden" name="__VIEWSTATE" value="(.*?)" /&gt;' query_state = re.findall(catch, exam_html.text)[0] query_config['__VIEWSTATE'] = query_state del query_state exam = requests.session().get(url=exam_url, data=query_config, headers=query_headers, cookies=loginobject.cookies) # print(course.text) # 测试ok # 写入文件 catch = '&lt;td&gt;(.*?)&lt;/td&gt;' exam_table = re.findall(catch, exam.text) del exam f = open("exam_arrangement.txt", "w") for each_line in exam_table: if "&amp;nbsp" in each_line: # TODO: 数据清洗 pass f.write(each_line + "\n") f.close() del exam_table # ----------------------------------- 结束 ----------------------------------------- # ----------------------------------等级考试成绩查询 -------------------------------- query_headers['Referer'] = classexam_url classexam_html = requests.get(classexam_url, cookies=loginobject.cookies, headers=query_headers) catch = '&lt;input type="hidden" name="__VIEWSTATE" value="(.*?)" /&gt;' query_state = re.findall(catch, classexam_html.text)[0] query_config['__VIEWSTATE'] = query_state del query_state classexam = requests.session().get(url=classexam_url, data=query_config, headers=query_headers, cookies=loginobject.cookies) # print(course.text) # 测试ok # 写入文件 catch = '&lt;td&gt;(.*?)&lt;/td&gt;' classexam_table = re.findall(catch, classexam.text) del classexam f = open("class_exam.txt", "w") for each_line in classexam_table: if "&amp;nbsp" in each_line: # TODO: 数据清洗 pass f.write(each_line + "\n") f.close() del classexam_table # --------------------------- 结束 -------------------------- # -------------------- 培养计划查询 ------------------------ query_headers['Referer'] = plan_url plan_html = requests.get(plan_url, cookies=loginobject.cookies, headers=query_headers) catch = '&lt;input type="hidden" name="__VIEWSTATE" value="(.*?)" /&gt;' query_state = re.findall(catch, plan_html.text)[0] query_config['__VIEWSTATE'] = query_state del query_state plan = requests.session().get(url=plan_url, data=query_config, headers=query_headers, cookies=loginobject.cookies) # print(course.text) # 测试ok # 写入文件 catch = '&lt;td&gt;(.*?)&lt;/td&gt;' plan_table = re.findall(catch, plan.text) del plan f = open("development_plan.txt", "w") for each_line in plan_table: if "&amp;nbsp" in each_line: # TODO: 数据清洗 pass f.write(each_line + "\n") f.close() del plan_table # --------------------- 结束 ---------------------------- # --------------------- 学生选课情况查询 ------------------------------ query_headers['Referer'] = select_course_url select_course_html = requests.get(select_course_url, cookies=loginobject.cookies, headers=query_headers) catch = '&lt;input type="hidden" name="__VIEWSTATE" value="(.*?)" /&gt;' query_state = re.findall(catch, select_course_html.text)[0] query_config['__VIEWSTATE'] = query_state del query_state select_course = requests.session().get(url=select_course_url, data=query_config, headers=query_headers, cookies=loginobject.cookies) # print(course.text) # 测试ok # 写入文件 catch = '&lt;td&gt;(.*?)&lt;/td&gt;' select_course_table = re.findall(catch, select_course.text) del select_course f = open("select_course.txt", "w") for each_line in select_course_table: if "&amp;nbsp" in each_line: # TODO: 数据清洗 pass f.write(each_line + "\n") f.close() del select_course_table # --------------------- 结束 ---------------------------- # ------------------- 补考开始查询 ---------------------- query_headers['Referer'] = add_exam_url add_exam_html = requests.get(add_exam_url, cookies=loginobject.cookies, headers=query_headers) catch = '&lt;input type="hidden" name="__VIEWSTATE" value="(.*?)" /&gt;' query_state = re.findall(catch, add_exam_html.text)[0] query_config['__VIEWSTATE'] = query_state del query_state add_exam = requests.session().get(url=add_exam_url, data=query_config, headers=query_headers, cookies=loginobject.cookies) # print(course.text) # 测试ok # 写入文件 catch = '&lt;td&gt;(.*?)&lt;/td&gt;' add_exam_table = re.findall(catch, add_exam.text) del add_exam f = open("add_exam.txt", "w") for each_line in add_exam_table: if "&amp;nbsp" in each_line: # TODO: 数据清洗 pass f.write(each_line + "\n") f.close() del add_exam_table # ------------------- 结束 ------------------------ print("------------查询成功-----------")if __name__ == '__main__': login = Login() doLogin(login, "./checkcode.png")]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python爬虫</tag>
        <tag>正方教务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C变量--声明、定义、赋值、初始化]]></title>
    <url>%2FC%E5%8F%98%E9%87%8F-%E5%A3%B0%E6%98%8E%E3%80%81%E5%AE%9A%E4%B9%89%E3%80%81%E8%B5%8B%E5%80%BC%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96.html</url>
    <content type="text"><![CDATA[出来混总是要还的，这不，来还大一C的陈年旧账了。打算深入细致的学习一下计算机，所以必须要从基础打起来。这篇文章算是扫盲篇吧。讲述C中的变量的声明、定义、赋值和初始化。为了让文章通俗易懂，我就只介绍一下它们的区别了吧。下一篇我们再讨论C/C++内存管理，会涉及const、static、auto等等这些变量类型。说明一下，这篇文章是关于C语言的变量的。 变量定义 变量的定义就是告诉编译器，我要创建一个变量了，你要找个地方将它存放起来，这个地方可以是堆栈(局部变量)，也可以是寄存器(寄存器变量)，还可以是…变量的定义指定了一个数据类型，可以是int，也可以是char，也可以是struct… 总结一下，变量的定义可以概括为：type variablelisttype表示的是变量的数据类型，variablelist表示的是一个变量列表，存放的是一个个变量，用逗号隔开。举个例子：int a,b,c;这里就定义了三个int类型的变量a,b,c 变量声明 那么什么是变量的声明呢？变量声明可以理解为程序员给编译器一个“保证”，程序员：“我待会要使用一个变量，但是这个变量我现在用不上，我先这样写者，你编译我程序的时候，不要报错。”所以，变量声明向编译器保证变量会以一定的类型和名称存在特定的地方，所以编译器就可以在不知道这个变量的细节的情况下，进行编译。值得一提的是，变量声明只在程序的编译时有效，链接时需要程序员给变量实际的变量定义，否则，报错。 变量的初始化变量的初始化是给变量赋予一个值。C中两种类型的表达式：左值表达式和右值表达式 左值早期的C给出的定义是：左值是一个表达式，可能出现在赋值操作的左边或右边，但右值只能出现在右边。我觉得这个定义实在是太模糊了，甚至它是错的。比如：a*b = 100显然这个写法是错误的，但是它符合上述说法。我的理解是：左值（lvalue）是一个表达式，它表示一个可被标识的（变量或对象的）内存位置，并且允许使用&amp;操作符来获取这块内存的地址。 123456789101112int i = 42;i = 43; int* p = &amp;i; // ok, i 是左值int&amp; foo();foo() = 42; // ok, foo() 是左值int* p1 = &amp;foo(); // ok, foo() 是左值int foobar();int j = 0;j = foobar(); // ok, foobar() 是右值int* p2 = &amp;foobar(); // 错误，不能获取右值的地址j = 42; // ok, 42 是右值 右值那么不是左值，便是右值了。 关于局部变量和全局变量局部变量需要程序员自己初始化，全局变量会被编译器自动初始化，但是我们还是应该养成良好的变成变成习惯，正确定义和初始化变量。int —&gt; 0double —&gt; 0float —&gt; 0char —&gt; 0ptr —&gt; NULL]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>声明</tag>
        <tag>赋值</tag>
        <tag>定义</tag>
        <tag>初始化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++对象模型--拷贝构造函数]]></title>
    <url>%2FC%2B%2B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.html</url>
    <content type="text"><![CDATA[接上一篇C++默认构造函数，这一篇我们来讲C++拷贝构造函数。 写在前面(关于深拷贝、浅拷贝)在此之前，先介绍一下： 浅拷贝只是对指针进行了拷贝，指针指向的地址并没有进行拷贝，拷贝后的指针和原指针指向同一块内存区域(这是很危险的、如果析构，会析构两次，导致内存泄漏！。我们的C++编译器合成的拷贝构造函数是执行浅拷贝，如果拷贝了指针(如Foo::*p)，必定会出错，这个指针会成为野指针 深拷贝对指针和指针指向的地址都进行拷贝，拷贝后的指针和原指针指向两块不同的内存区域，所以，执行深拷贝，需要开辟新的内存空间。 区别来看一个例子：TestA.cpp 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt; using namespace std;class Student&#123;private: int num; char *name;public: Student(); ~Student();&#125;; Student::Student()&#123; name = new char(20); cout &lt;&lt; "Student" &lt;&lt; endl;&#125;Student::~Student()&#123; cout &lt;&lt; "~Student " &lt;&lt; name &lt;&lt; endl; delete name; name = NULL;&#125; int main()&#123; &#123;// 花括号让s1和s2变成局部对象，方便测试 Student s1; Student s2(s1);// 调用默认拷贝构造函数 &#125; return 0;&#125; 运行结果： 1234Student~Student ~Student *** Error in `./a.out': double free or corruption (fasttop): 0x00000000010f9c20 *** 很显然，报出了一个错误，double free，也就是进行两次析构，这是不允许的。为什么呢？因为我这里调用的是编译器合成的拷贝构造函数，它进行的是浅拷贝，拷贝后s1.name和s2.name都是指向同一块内存区域，对同一块内存区域进行两次释放，能不出错吗？ 我们来gdb一下看看：这是对s2进行拷贝初始化之前，s2这时候还不存在，内存地址都还是起始地址 123$1 = &#123;num = 2, name = 0x614c20 "\024"&#125;(gdb) p s2$2 = &#123;num = 0, name = 0x0&#125; 这是对s2进行拷贝初始化之后，s2这时候和s1的数据成员完全一致，也就是说，我们的拷贝构造函数只是对s1.name和s1.num进行了简单的复制，赋值给s2 1234(gdb) p s2$3 = &#123;num = 2, name = 0x614c20 "\024"&#125;(gdb) p s1$4 = &#123;num = 2, name = 0x614c20 "\024"&#125; 我们修改一下原来的代码、加上一个user-defined拷贝构造函数，进行深拷贝：TestB.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std; class Student&#123;private: int num; char *name;public: Student(); Student(const Student &amp; stu); ~Student();&#125;; Student::Student()&#123; name = new char(20); cout &lt;&lt; "Student" &lt;&lt; endl; &#125;Student::~Student()&#123; cout &lt;&lt; "~Student " &lt;&lt; name &lt;&lt; endl; delete name; name = NULL;&#125;// 深拷贝构造函数Student::Student( const Student &amp; stu ) &#123; num = stu.num; name = new char[20]; if ( name!= NULL ) strcpy(name, stu.name);&#125; int main()&#123; &#123;// 花括号让s1和s2变成局部对象，方便测试 Student s1; Student s2(s1); cout &lt;&lt; "结束" &lt;&lt; endl; &#125; return 0;&#125; 运行结果： 123Student~Student ~Student  这次没有出现重复析构的错误了，输出的是我们希望的结果，我们再一次gdb看一下： 1234(gdb) p s1$3 = &#123;num = 2, name = 0x614c20 "\024"&#125;(gdb) p s2$4 = &#123;num = 2, name = 0x615050 "\024"&#125; 刚刚为TestB.cpp加上了一个拷贝构造函数，所以执行Student s2(s1)的时候，会调用我定义的Student(const Student &amp;stu)这个拷贝构造函数，执行深拷贝，即为s2对象的name属性开辟新的内存空间(首地址0x615050)，使得name指针指向这个新开辟的内存地址，而不是原来的s1的name指针所指向的地址(首地址0x614c20)，这样在析构的时候，便没有内存泄漏的错误了。 使用知道区别之后，那么我们什么时候该用浅拷贝、什么时候该用深拷贝？或许上面的例子是一个答案，当我们需要对动态的数据类型(指针、数组等)进行拷贝的时候，使用深拷贝，防止内存泄漏、指针悬挂问题的出现。当然大多数情况下，浅拷贝就可以解决我们的问题了。 拷贝构造函数什么是拷贝构造函数 对于普通的内置数据类型，要对它们进行复制很简单，只需要简单的赋值操作符就可以了 类对象数据类型就不行了，它比较复杂，有各种各样的成员变量 我们看一个例子： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt; using namespace std; class Foo &#123; private: int a; public: //构造函数 Foo(int b) &#123; a = b;&#125; //拷贝构造函数 Foo(const Foo &amp; C) &#123; a = C.a; &#125; void Show () &#123; cout&lt;&lt;a&lt;&lt;endl; &#125; &#125;; int main() &#123; Foo A(100); Foo B(A); //Foo B = A; B.Show (); return 0; &#125; 这里的Foo(const Foo &amp; c)就是一个拷贝构造函数，它是一种特殊的构造函数，参数中必须要有一个是这个类的类型的引用变量，一个类中可以有多个拷贝构造函数。 何时调用1. 对象需要通过另外一个对象进行初始化这一点显而易见 12Foo a(b); // 拷贝构造函数Foo a = b; // 拷贝赋值操作符 2. 对象以值传递的方式传入函数参数 12345678910111213141516171819202122232425262728293031323334353637383940class Foo &#123; private: int a;public: Foo(int b) &#123; a = b; cout&lt;&lt;"creat: "&lt;&lt;a&lt;&lt;endl; &#125; Foo(const Foo&amp; C) &#123; a = C.a; cout&lt;&lt;"copy"&lt;&lt;endl; &#125; ~Foo() &#123; cout&lt;&lt; "delete: "&lt;&lt;a&lt;&lt;endl; &#125; void Show () &#123; cout&lt;&lt;a&lt;&lt;endl; &#125; &#125;; //全局函数，传入的是对象 void Foo_bar(Foo C) &#123; cout&lt;&lt;"test"&lt;&lt;endl; &#125; int main() &#123; Foo test(1); //传入对象 Foo_bar(test); return 0; &#125; 调用Foo_bar()的过程中，会有如下操作： test作为实参传入Foo_bar()函数的形参，生成临时Foo对象tmp 调用拷贝构造函数，把test的值传递给tmp,一、二操作在一起就是Foo tmp(test) Foo_bar()函数执行完之后，调用析构函数，析构tmp对象 3. 对象以值传递的方式从函数返回 123456789101112131415161718192021222324252627282930313233343536373839class Foo &#123; private: int a;public: Foo(int b) &#123; a = b; cout&lt;&lt;"creat: "&lt;&lt;a&lt;&lt;endl; &#125; Foo(const Foo&amp; C) &#123; a = C.a; cout&lt;&lt;"copy"&lt;&lt;endl; &#125; ~Foo() &#123; cout&lt;&lt; "delete: "&lt;&lt;a&lt;&lt;endl; &#125; void Show () &#123; cout&lt;&lt;a&lt;&lt;endl; &#125; &#125;; //全局函数，传入的是对象 Foo Foo_bar() &#123; Foo test_local(100); return test_local;&#125; int main() &#123; Foo_bar(); return 0; &#125; 当Foo_bar()执行到return 语句时候： 产生一个临时对象tmp 调用拷贝构造函数，把test_local的值传递给tmp,一、二操作在一起就是Foo tmp(test_local) Foo_bar()函数执行到最后，调用析构函数，先析构test_local对象，再析构tmp对象 一些注意事项 拷贝构造函数不能对static member进行拷贝赋值，因为static member属于这个类，而不被某个特定的对象所拥有 写在后面暂时就想到这么多，后面再进行补充。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>对象模型</tag>
        <tag>拷贝构造函数</tag>
        <tag>深拷贝</tag>
        <tag>浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++对象模型--默认构造函数]]></title>
    <url>%2FC%2B%2B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.html</url>
    <content type="text"><![CDATA[这篇文章主要讲解C++中默认构造函数的机制，同时解决了困扰了我很久的问题，长篇文章，话不多说，开干！ 写在前面C++编译器为程序员自动提供下面这些成员函数(在合适的时候)： 默认构造函数 默认析构函数 拷贝构造函数 赋值运算符 地址运算符 移动构造函数(C++11) 移动赋值运算符(C++11) 默认构造函数错误的、不全面的认识： 如果程序员没有定义默认的构造函数，那么编译器就会提供一个默认构造函数，来完成对成员的初始化 编译器合成出来的默认构造函数会明确的设置类的每个数据成员的值 正确认识： 默认构造函数只在“被需要”的时候，才会被编译器合成，可能是有用或无用 对构造函数的需求分为程序需求和编译器需求 一个有用的默认构造函数在必要的时候(4种情况下)也会被编译器合成 带有默认构造函数的类对象成员 带有默认构造函数的基类 带有虚函数的类 带有虚基类的类 编译器合成的默认构造函数，不会初始化用户定义的类成员，退一步说，只会初始化编译器“需要的”成员 编译器只做编译器自己的事，程序员的事需要程序员自己做 何谓默认构造函数 C++ Annotated Reference Manual(ARM)中提及到：“default constrcutor在需要的时候会被编译器产生出来。” 那这里问题来了，“在需要的时候”，到底是什么时候？又是被谁需要？用来做什么事情？以下代码为例： 123456789101112class Foo &#123;public: int val; Foo *pnext;&#125;;void foo_bar() &#123; Foo bar; if ( bar.val || bar.pnext ) &#123; // do something &#125;&#125; 在这个程序中，要求val 和 pnext都必须被初始化为0，那么代码中并没有提供setter函数，只有通过和构造函数来初始化，但是代码也没有(显式)提供构造函数。那么这个情形是否符合上述的“在需要的时候”？答案当然是：NO。对“在需要的时候”，可以分为程序需要和编译器需要，至于前者，那是我们程序员自己的事，我们需要，那我们就自己写构造；后者，是编译器的工作。那么本例中的当然是程序需要，提供默认构造函数的责任就在于程序员。所以上述程序不会生成一个默认构造函数。 那么，什么时候才会合成一个默认构造函数？当编译器需要的时候！被合成出来的默认构造函数执行编译器所需要的行为(想想都很可怕，我们都不知编译器到底在背后做了什么)，因此，即便编译器为程序合成了一个默认构造函数，这个构造函数也不会执行我们希望的操作，就是说，这个Foo()构造函数不会把val和pnext都初始化为0，也就是我们所说的编译器合成的无用的默认构造函数(trivial)，C++ Standard[ISO-C++95]中的原话是，“对于class X，如果没有任何user-defined constructor，那么会有一个default constructor会被隐式声明出来，一个隐式声明出来的defalut constructor是一个trivial constructor”。 我们验证一下： 代码A： 123456789101112131415161718#include &lt;iostream&gt;using namespace std;class Foo &#123;public: int val; Foo *pnext;&#125;;void Foo_bar() &#123; Foo bar; cout &lt;&lt; bar.val &lt;&lt; endl; cout &lt;&lt; bar.pnext &lt;&lt; endl; &#125;int main() &#123; Foo_bar(); return 0;&#125; g++编译运行结果： 1241966240x400770 clang++编译运行结果： 1200 初步怀疑，与编译器有关？ g++编译gdb调试： 1$1 = &#123;val = 4196624, pnext = 0x400770 &lt;_start&gt;&#125; clang++编译gdb调试： 1$2 = &#123;val = 0, pnext = 0x0&#125; 另外，在线编译器爆出了一个warnning: 123456789101112Startprog.cc: In function 'void Foo_bar()':prog.cc:11:14: warning: 'bar.Foo::val' is used uninitialized in this function [-Wuninitialized] 11 | cout &lt;&lt; bar.val &lt;&lt; endl; | ^~~prog.cc:12:17: warning: 'bar.Foo::pnext' may be used uninitialized in this function [-Wmaybe-uninitialized] 12 | cout &lt;&lt; bar.pnext &lt;&lt; endl; | ~~~~^~~~~41977920x400c200Finish 意思是val和pnext没有被初始化，这就说明了我们的无用的默认构造函数没有对类成员进行初始化，在这里，貌似要解释一下初始化和赋值 代码B： 12345678910111213141516#include &lt;iostream&gt;using namespace std;class Foo &#123;public: int val; Foo *pnext;&#125;;void Foo_bar() &#123; Foo bar;&#125;int main() &#123; Foo_bar(); return 0;&#125; g++编译，gdb调试结果： 1$1 = &#123;val = 4196128, pnext = 0x4005c0 &lt;_start&gt;&#125; 可见，这里的val = 4196128, 貌似是一个随机生成的数值。 clang++编译，gdb调试结果：1$1 = &#123;val = 0, pnext = 0x0&#125; 此上，基本可以推断出，默认构造函数的行为貌似与编译器有关？但是可以肯定的是， non-trivial(有用的)默认构造函数带有defalut constructor的member class object举个例子： 123456789101112131415161718class Foo &#123;public: Foo(); Foo(int val);&#125;;class Bar &#123;public: Foo foo; // 不是继承，是内含! char *str;&#125;;void foo_bar() &#123; Bar bar; //Bar::foo必须在这里初始化 if ( str ) &#123; //do something &#125;&#125; 我们的Foo是一个拥有默认构造函数的一个类，当Foo的一个对象foo作为我们的Bar类的一个成员，同时Bar类没有任何构造函数的时候，那么这个类的implicit default constructor就是nontrivial的，编译器为就会在Bar类的constructor真正需要的时候，为其合成一个默认构造函数。被合成的Bar类的构造函数，里面有必要的代码，能够调用Foo::Foo()对Bar::foo进行处理，但是Bar::str需要程序员来初始化，我们大胆猜测一下，编译器合成的Bar::Bar()可能是这样子的： 123inline Bar::Bar() &#123; foo.Foo::Foo(); //伪代码&#125; 同时，我们程序员还会写一个Bar::Bar()，对Bar::str初始化： 123Bar::Bar() &#123; str = 0;&#125; 现在好了，程序的需求已经得到满足了，但是我们的Bar::foo还没有初始化，但是这里程序员已经显式定义了默认构造函数，所以编译器无法再次合成了，怎么办呢？编译器的做法是：“如果Class A内含有一个或者一个以上的member class object，那么Class A的每一个构造函数都必须调用每一个member class的默认构造函数”*，即编译器会扩张已经存在的构造函数，在其中安插一些代码，在user code被执行之前，调用相应的defalut constructor。 所以，扩张后的构造函数可能是这样的： 1234Bar::Bar() &#123; foo.Foo::Foo(); // 编译器插入的 str = 0; // 程序员写的&#125; 最后说一点，如果Bar类有多个member class object怎么办？当然是按上面的道理来，只不过对这些object，按照它们声明的顺序来初始化。 带有defalut constructor的base class顾名思义，如果一个没有任何构造函数的继承于一个带有默认构造函数的基类，那么编译器就会为这个类合成一个默认构造函数，这个构造函数会调用上一层继承类的默认构造函数。那么如果程序员为这个类写了很多个构造函数，但是就是没有默认构造函数，怎么办？编译器会把默认构造函数中需要的代码插入到所有的现有的构造函数中，那么如果上述第一种情况也存在呢？答案是，这些构造函数会在基类构造函数被调用之后，再被调用。 带有一个virtual function的class这个与C++中的虚函数的机制有关，参见C++虚函数机制，以下代码为例： 1234567891011121314151617class Widget &#123;public: virtual void flip() = 0; // ...&#125;;void flip(const Widget &amp; widget) &#123; widget.flip();&#125;// 假设Bell和Whistle都是继承于Widgetvoid foo() &#123; Bell b; Whistle w; flip(b); flip(w);-&#125; 一个虚函数表vtbl会在编译的时候被合成出来，用来存放虚函数的地址 在每一个Widget对象中，都会有一个额外的指针成员vptr，用来存放虚函数表的地址 此外，widget.flip()的虚拟调用操作会被重新改写，因为flip()在vtbl中是需要通过索引来获得的。可能的代码如下： 1(*widget.vptr[1]) (&amp;widget) // &amp;widget是this指针 至于索引为什么是1？因为vtbl中的第一个元素存放的是type_info 为了让这个机制有效，编译器必须需要为每一个Widget或其派生类的对象的vptr赋值，放上适当的vtbl的地址。对于class所定义的每一个构造函数，编译器都会插入一些代码来完成这样的事情；对于那些没有定义任何构造函数的class，编译器ｈｉ合成一个这样的默认构造函数，完成对vptr的初始化。 带有一个virtual base class的class这一条没有弄懂….. trivial(无用的)默认构造函数(实际上不存在)不满足上述4种情况、没有显式提供user-defined constructor的时候，这个默认构造函数叫implicit trivial default constructor，实际上编译器根本不会合成这样的一个构造函数。 编译器如何合成默认构造函数当程序员没有定义构造函数时，编译器会合成一个默认构造函数，来完成编译器需要的工作；当程序员定义了自己的构造函数时，有时候，编译器也会对它“需要的”一些成员进行操作，这时候，编译器的做法是：修改构造函数，在程序员写的构造函数里添加代码，添加的代码位于程序员的代码之前。 小结 默认构造函数只有在上述4种情况下，才会由编译器强制合成，C++ Standard称之为implicit nontrivial default constructor，它只会满足编译器的需要，其他事一概不会做。 对那些不满足上述4种情况、没有任何user-defined constructor的类，我们说它拥有的是implicit trivial default constructor，实际上，这个默认构造函数根本不会被合成。 在合成的默认构造函数中，只有基类的子对象、类的成员对象会被初始化，所有其他的nonstatic data member(如整数、整数指针、整数数组等)都不会被初始化，这些初始化对于程序而言或许很重要，但是编译器它管你干啥子。 自己的事情自己做，编译器合成出来的构造函数只会做编译器需要做的工作，其他的工作需要程序员自己想办法。 成员初始化列表(补充说明)初识C++还提供了一种初始化成员的方法：成员初始化列表何为初始化列表？看个例子： 12345678910111213141516171819class Foo &#123;public: int a; float b; // 初始化列表初始化 Foo(int _a, float _b):a(_a),b(_b) &#123; &#125; // 一般赋值运算符初始化 Foo(int _a, float _b) &#123; a = _a; b = _b; &#125; ~Foo() &#123; &#125;&#125;; 如上的Foo(int _a, float _b):a(_a),b(_b) { }就是一个含有列表初始化式的构造函数，观察上述两种初始化的方法，貌似没有区别，真的是这样的吗？首先区别肯定是有的，而且C++ Primer中明确提出，有的时候，必须要使用成员初始化列表，否则编译器就会爆出错误！ 本质初始化列表的本质是什么？举个例子： 12345678910class Word &#123;private: String name; int count;public: Word():name(0) &#123; count = 0; &#125;&#125;; 我们猜测一下，这个name是如何被初始化的。 1234567// C++伪代码Word::Word(*this)&#123; // String(int) 构造 name.String::String(0); count = 0;&#125; 这里，0 要被String类的String(int)构造函数来构造成一个String对象，然后才能对name初始化。也就是说，对于成员初始化列表，编译器会将其按照变量声明顺序来处理(也不是绝对的，后面会给出例子)，插入一些代码到构造函数中的任何user-defined code之前。 何时使用1. 编译器要求的时候深度探索C++对象模型中提到，在以下四种情况，对成员的初始化必须要使用成员初始化列表： 初始化一个reference member 初始化一个const member 调用base class的constructor，而它拥有一组参数 调用member class的constructor，而它拥有一组参数 下面对以上四种情况给出说明： 初始化reference member我们知道引用一经指定，便不可以再改变，一个引用的成员在声明之后，不可以进行赋值。 12345678910111213141516171819202122class Foo &#123;public: int a; int &amp;b; // 一般赋值运算符初始化 Foo(int _a, int _b) &#123; a = _a; b = _b; &#125; ~Foo() &#123; &#125;&#125;; int main() &#123; Foo foo(1, 2); return 0;&#125; 报错： 12345675.cpp: In constructor ‘Foo::Foo(int, int)’:5.cpp:9:5: error: uninitialized reference member in ‘int&amp;’ [-fpermissive] Foo(int _a, int _b) ^5.cpp:4:10: note: ‘int&amp; Foo::b’ should be initialized int &amp;b; ^ 说我Foo::b没有初始化，也就是把b放在构造函数中，不能够正确初始化，那么我们来改一下： 123456789101112131415161718class Foo &#123;public: int a; int &amp;b; Foo(int _a, int _b):b(_b) &#123; a = _a; &#125; ~Foo() &#123; &#125;&#125;; int main() &#123; Foo foo(1, 2); return 0;&#125; 这样是没有问题的了。 初始化const member为什么const member需要使用成员初始化列表呢？貌似不可理解。实际上，const成员在声明后就马上需要初始化，如果放在构造函数中，执行的是赋值操作，这是不允许的。我们来试试用构造函数初始化const member：TestA.cpp： 123456789101112131415161718192021222324class Foo &#123;public: int a; const float b; // 初始化列表初始化 //o(int _a, float _b):a(_a),b(_b) //&#125; // 一般赋值运算符初始化 Foo(int _a, float _b) &#123; a = _a; b = _b; &#125; ~Foo() &#123; &#125;&#125;; int main() &#123; Foo foo(1, 0.1); return 0;&#125; 编译报错： 123456789105.cpp: In constructor ‘Foo::Foo(int, float)’:5.cpp:9:5: error: uninitialized const member in ‘const float’ [-fpermissive] Foo(int _a, float _b) ^5.cpp:4:17: note: ‘const float Foo::b’ should be initialized const float b; ^5.cpp:12:11: error: assignment of read-only member ‘Foo::b’ b = _b; ^ 他说，我对只读的成员Foo::b赋值了，如你所见，因为const成员变量一经声明或定义，就不可以在修改，而我们放在构造函数中，进行的是赋值操作，所以编译器会报错。所以const member必须要用成员列表初始化。 调用base class的constructor，而它拥有一组参数即: 初始化基类的成员，而且这个基类只有带参数的构造函数，没有无参构造函数TestB.cpp 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;class Foo &#123;public: int a; float b; // 一般赋值运算符初始化 Foo(int _a, float _b) &#123; a = _a; b = _b; &#125; ~Foo() &#123; &#125;&#125;; class Bar:public Foo &#123;public: int c; Bar(int _a, int _b, int _c):c(_c),Foo(_a,_b) &#123; &#125; ~Bar() &#123; &#125;&#125;;int main() &#123; Bar bar(1,2.2,2); cout &lt;&lt; bar.a &lt;&lt;endl &lt;&lt; bar.b &lt;&lt; endl &lt;&lt; bar.c &lt;&lt;endl; return 0;&#125; 运行结果： 123122 调用member class的constructor，而它拥有一组参数即初始化的是一个类对象成员，而且这个类成员所对应的类只有带参数的构造函数，没有无参的构造函数。这一点貌似与上一条类似？ 2. 程序效率要求的时候这点先放着，等我搞懂初始化、赋值、定义、声明后在写。 1234567891011class Word &#123;private: String name; int count;public: Word() &#123; name = 0; count = 0; &#125;&#125;; 注意C++初始化列表的初始化顺序是什么样的呢？与初始化列表的变量出现顺序无关，而是和变量的声明顺序有关！但是答案就是绝对的了吗？看个例子： 12345678class X &#123; int i; int j;public: X(int val) :j(val), i(j) &#123; &#125;&#125;; 这里你发现了什么？没错！如果按照变量声明的顺序来初始化的话，那么就是先初始化i，在初始化j，那么这个构造函数必定会出错，因为用j来初始化i，此时j还没有被初始化！！！所以说，初始化列表的初始化顺序也不是确定的，要视具体情况而定。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>对象模型</tag>
        <tag>默认构造函数</tag>
        <tag>初始化列表</tag>
        <tag>虚函数</tag>
        <tag>虚基类</tag>
        <tag>vtbl</tag>
        <tag>vptr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP(一)--计算机系统漫游]]></title>
    <url>%2FCSAPP-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8.html</url>
    <content type="text"><![CDATA[计算机系统学习狂补知识ing… 计算机系统计算机系统是由计算机硬件和系统软件组成的，它们共同工作来与进行应用程序。接下来，我会以hello.c为例，进行一些零散的总结。 12345#include &lt;stdio.h&gt;int main() &#123; printf("Hello World!\n"); return 0;&#125; 信息信息就是位+上下文，我们的hello.c文件叫源文件、源程序，实际上就是一个由值0和1组成的位序列，叫比特(bit)，8个位被组织成一组，成为一个字节(byte)，每个字节表示程序中的某些文本字符，现在大部分的计算机都使用ANSII标准来存储字符，每个字符都对应唯一的单字节大小的整数值，叫ANSII值。 编译系统目前的C、C++、Pascal等都是高级语言，汇编语言也是一些汇编指令，只有最低级的机器指令(0、１序列)才能够被计算机直接“识别”，所以说，要想运行一串高级语言代码，必须要有一样东西，把这些高级语言代码转换为计算机能够直接识别的机器指令，这就是编译器的作用。一个计算机编译系统，由四部分组成： 预处理器(ccp) 编译器(ccl) 汇编器(as) 链接器(ld)相应的，一个程序的编译过程，也分为四个阶段： 预处理阶段预处理器会扫描源文件，定位到以”#”开头的内容，根据这个内容，修改源文件的内容，比如说前面#include &lt;stdio.h&gt;，这时候，我就要找到stdio.h这个头文件，把这个头文件的内容直接插入到hello.c源文件中(至于具体在哪个位置，我们不知道)，生成新的源文件hello.i，通常以.i作为文件扩展名。 编译阶段编译器会将文本文件hello.i翻译成文本文件hello.s，它包含了一个汇编语言程序，。即将高级语言翻译成汇编语言。的汇编程序可以为不同的高级语言和不同的编译器提供通用的输出语言。gcc -S hello.s hello.c 汇编阶段汇编器将汇编语言翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，将结果放在hello.o这个二进制文件中。gcc -c hello.o hello.c 链接阶段我们的hell.o调用了stdio的printf()函数，它是C语言的一个标准库函数，位于printf.o这个独立的预编译好了的目标文件中，必须要加入我们的hello.o文件中，程序才能够正常运行。链接器就是做这个工作的，将printf.o文件与hello.o文件链接，得到hello可执行目标文件，当然，也是二进制文件。这个可执行目标文件可以加载到内存中，被计算机所执行。gcc -o hello hello.c 这样的命令会生成可执行文件hello，一般没有后缀。 了解编译系统的工作流程带来的好处： 优化程序性能比如说，switch就会比if效率高吗？while和for的效率问题，函数调用的开销到底有多大，传指针和传值到底有什么区别？这些目前我还不清楚、或者说不太清楚，所知道的也就是从书上、网上学来的。或许学了程序的编译过程，就会明白了把。 理解链接时的错误写代码时，经常会遇到链接错误，顺带提一下，动态链接和静态链接，待学习。 动态链接和静态链接1. 动态链接 Windows: .lib文件 Linux: .a文件 函数库的一份拷贝是可执行文件的物理组成部分，称之为静态链接。静态链接当链接程序时，需要使用的每个库函数的一份拷贝被加入到可执行文件中。静态链接使用静态库进行链接，生成的程序包含程序运行所需要的全部库，可以直接运行，不过静态链接生成的程序体积较大（即使是在静态链接中，整个库文件也并没有全部装入到可执行文件中，所装入的只是需要的函数）。2. 静态链接 Windows: .dll文件 Linux: .so文件 如果可执行文件只是包含了文件名，让载入器在运行时能够寻找程序所需要的函数库，称之为动态链接。动态链接允许系统提供一个庞大的函数库集合，可以提供许多有用的服务，程序在运行时寻找它们。动态链接使用动态链接库进行链接，生成的程序在执行的时候需要加载所需的动态库才能运行。动态链接生成的程序体积较小，但是必须依赖所需的动态库，否则无法执行。3. 细节 gcc编译器默认使用动态编译，如果要指定静态编译，需要加上-static参数]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
        <tag>动态链接</tag>
        <tag>静态链接</tag>
        <tag>编译系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机系统基础--学习开篇]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E5%BC%80%E7%AF%87.html</url>
    <content type="text"><![CDATA[写在前面 作为一个非科班出身的半吊子程序员(程序员?)，在和计算机专业的同学交流的过程中，切实感受到知识面的匮乏，总体体现在对计算机系统的理解。确实，作为一名双非院校信管专业的学生，本身起步就比别人慢了不少，若没有扎实的基本功，将来怎么与别人竞争。 在自学了将近一年的代码之后，随着代码量的增加，越发觉得基础知识的匮乏，对指针理解的不够透彻，对程序代码的执行情况也是一知半解。不过也不失为一件好事，最怕的就是发现不了问题，故开设这篇博客，记录下以后学习的过程。先给自己定个学习路线吧: 计算机系统基础NJU袁春凤 + MOOC，为期一个学期，势必拿下 CSAPP 我的计算机学习之路 要说我真正的计算机学习之路，是我的导师领我进门的。是从学Python代码开始的，虽然大一下开的C，当时也只是记住了一些计算机常识，并没有过多的去重视，后来时间到了大二，一天我的导师找到我，问了我有没有兴趣搞代码。在这里顺便啰嗦一下，给我的学弟学妹们吧。 信管专业，是个交叉学科，学的东西多且复杂，简单的来说是计算机学科知识也管理科学相交叉的产物。在这个大环境下，如果没有明确的目标，那么四年后你将一事无成。所以，在大一下，对自己的专业有了一定的认识之后，就应该明确自己以后的学习方向，是搞代码还是搞管理，还是搞测试，还是搞其他的，最晚最晚大二上也要定好方向了。这里我假设你选择的是技术路线，无论你是搞运维还是搞开发还是搞测试，总之都得与代码打交道。所有你就要在平时学习中多动手，多动脑。但是问题来了，我的专业是分在管院，顾名思义，侧重的是管理科学，所以如果想做技术的话，要下狠功夫，狠补计算机相关知识。其实我觉得可以先学着一两门编程语言，在学习的过程中，你会发现自己专业知识的缺乏，有的时候一些问题会感觉无从下手，这个时候，你已经有了一定的编程基础(注意编程能力和项目能力的区别)，带着问题和目的的取学习一样东西往往是最高效的。 我还是很菜，虽然有一些Linux开发经验，但是对于Linux系统底层的机制还是不懂，是完全不懂啊。先前试着看了Linux内核源码，无奈看不懂。。也是，没有计算机系统基础知识，怎么能读它。所以说，要学好计算机，就必须先要把入门课补回来。出来混总是要还的～～ ps: 编程能力侧重动脑能力，指的是完成小程序、算法相关的能力，pta,leetcode… 项目能力侧重动手能力，要求能够合理使用现有资源(API、框架…)开发出一个完整的项目，例如：管理系统，坦克大战… 学习之路先看着南大的MOOC学习，它是根据CSAPP改编而来，我看了一下感觉挺好，容易理解。未完待续…]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
        <tag>CS</tag>
        <tag>学习生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web--浅谈jsp与servlet]]></title>
    <url>%2Fweb-%E6%B5%85%E8%B0%88jsp%E4%B8%8Eservlet.html</url>
    <content type="text"><![CDATA[JSP和servlet区别 jsp的本质就是servlet，jsp经过编译后会转化成servlet因为jvm只能识别java类，不能识别其他的类文件，所以就有了一系列的web容器(服务器)，如tomcat，这些容器将jsp编译成jvm能够识别的java类 一般来说，jsp用于页面展示，servlet用于逻辑控制比如说要实现一个用户登录模块，我们会把页面显示交给jsp，内部逻辑控制交给servlet servlet没有内置对象，jsp有一些内置对象 联系 servlet是严格意义上的java类，它在MVC模型中是控制层，它与表现层完全分离 jsp可以是html标签，可以嵌入java代码，它是表现层，侧重于视图 做好理解 不同之处servlet通过java代码httpServletResponse对象向客户端动态输出html内容，就是说，如果我要在servlet中向客户端输出或者展示一些东西，必须要以html标签的形式 各自特点servlet可以很好的组织业务逻辑，但是通过以字符串的形式向客户端传送html标签使得代码维护起来比较困难。但是一概的在jsp里面混入大量的业务逻辑也是不可取的。 如何均衡那么如何做到二者的优势互补？答案当然是MVC，MVC是一种软件架构，分为: 模型层(Model)—业务逻辑 视图层(View)—负责页面显示 控制层(Controler)—负责相关交互操作 示例demo这个小demo主要实现了html表单的用户登录操作，然后记录用户的提交信息，返回给客户端。 1. loginServlet.java 12345678910111213141516171819202122232425262728293031323334353637383940package servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(urlPatterns = "/login", name = "login")/** * 这里是 servlet负责页面显示， 也可以是SERVLET负责数据处理, jsp 负责页面显示 */public class LoginServlet extends HttpServlet &#123; public static final long serialVersionUID = 1L; public LoginServlet() &#123; super(); &#125; // post 提交浏览器不会显示，比较安全 protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 设置页面编码格式 request.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=UTF-8"); String user = request.getParameter("user"); // 这样写是没有效果的，servlet向浏览器输出内容，浏览器只能解析html,所以要用html标签向页面传送信息 //response.getWriter().println(user); //response.getWriter().print("这是登录界面"); // response.getWriter() 获得一个输出流 String string = "&lt;html&gt; &lt;head&gt; &lt;title&gt;这是servlet返回的结果&lt;/title&gt;&lt;/head&gt; &lt;body&gt; 欢迎 " + user + "&lt;/body&gt; &lt;/html&gt;"; response.getWriter().print(string); &#125;&#125; 2. login.jsp 1234567891011121314151617181920212223242526&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;servlet测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="login" method="post"&gt; &lt;table&gt; &lt;tb&gt; uesr: &lt;input type="text" name="user"&gt; &lt;br&gt; &lt;/tb&gt; &lt;tb&gt; passwd: &lt;input type="password" name="passwd"&gt; &lt;br&gt; &lt;/tb&gt; &lt;/table&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 测试结果可以知道，我输入的user是“servler测试”，点击登录按钮后，返回给客户端的就是用户提交的user值，”servlet测试“。 页面提交 信息返回]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>jsp</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java web--servlet学习]]></title>
    <url>%2Fservlet%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[接上篇，学习servlet基础。 servlet是什么java servlet是运行在web服务器上的应用程序，实现动态页面的创建，作为来自web浏览器和其他http客户端请求和http服务器上的数据库或者应用程序之间的中间层。 http请求和响应过程 servlet架构 架构 tomcat与servlet 这里可以知道，tomcat将浏览器发过来的http请求(http request)文本接收并解析，封装成httpServlet类型的request对象 tomcat服务器同时将要响应的信息封装成httpResponse类型的response对象，通过设置response的相关属性就可以控制输出到浏览器的内容，再将response交给tomcat，tomcat就会将其转换成要响应的文本格式返回给浏览器 servlet任务 读取客户端发送的显式数据，包括html表单，或者是applet或者用户定义程序的表单 读取客户端发送的隐式http请求，包括cookies等 处理数据并获得结果，可能会访问数据库调用web服务 发送显式的数据到客户端，可能是文档、图片等 发送隐式的http响应到客户端 java servlet包java servlet是运行在带有servlet解释器的web服务器(我用的是tomcat)上的java类。通常需要import javax.servlet.*来导入包。java servlet API 是servlet容器(tomcat为例)和servlet之间的接口，定义了各种servlet方法，和一些对象，其中主要是servletRequest和servletResponse对象比较重要。 编写servlet编写servlet有两种方法： 直接编写servlet类，实现相应的方法这个方法需要编写完整的java类，比较复杂，而且容易出错。故我们采用第二种方法。 用IDE(我的是idea)新建myServlet新建myServlet，默认会实现doGet()和doPost()方法，也可以根据自己的需要，实现其他方法，诸如：init()、service()、destory() 另外，要实现与jsp的交互，必须要配置web.xml文件，写入servlet、servlet-mapping等标签，除此之外，也可以在servlet类的添加注释(annoation)，例如： @WebServlet(urlPatterns = &quot;/signin&quot;, name = &quot;signin&quot;)，这样就可以不用配置web.xml文件 详解servlet原理1. servlet生命周期 servlet的生命周期始于servlet服务器启动时或者第一次请求该servlet，此时调用init()方法，初始化出一个servlet对象 servlet处理所有的客户端请求，执行service()方法 服务器关闭，执行destory()方法，servlet被销毁 2. servlet的service()方法这里有个问题，我们在编写servlet时，只写了doPost()和doGet()方法，并没有写service()方法，那么servlet是如何执行service()方法的呢？public的service()方法，这是对外的公有方法，这里做了一个ServletRequest到httpServletRequest的转型 内部的protected的方法，根据请求的方法method不同，调用不同的响应方式： 也就是说，service()方法一般情况下我们是不需要重写的，它已经包括的所有的推理机，我们只要重写相应需要的方法就行了，比如说doPost()、doGet()，这也是idea默认给我们重写的两个方法。3. servlet重要的对象servlet为我们创建了几个内置对象： servletCopnfig servletContext httpServletRequest httpServletResponse]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++对象模型--关于对象]]></title>
    <url>%2FC%2B%2B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B--%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1.html</url>
    <content type="text"><![CDATA[写在前面为什么要写C++一栏的博客呢?其实是为了加深理解和敦促学习，我发现只要离开写博客，人就变得懒散起来，每天写的代码零零散散，C++这门课程是在大二上开的，上课也就水水过去了，老师上课其实也还挺好，无奈听不懂啊，听不懂就不想听啊。现在想想挺后悔的。后来由于实验室需要，而且自己也意识到C++的重要性，于是便自学。(貌似我所有的编程语言都是自学的、除了大一的C)至于自学，我的做法是，找博客，一个一个知识点地去学，后来也勉强算是入门了把。好记性不如烂笔头，于是还是记录下来比较好。 关于入门入门书籍的选取太重要了。谁要是和你推荐诸如21天学通C++、Visual C++ xxx的，可以绝交了(滑稽)，我推荐C++ primer而不是C++ primer plus，不是带了个plus就是更牛x一点，相反，plus对于新入门的来说，讲的太过细致，有点晦涩，以至于你想放弃。搞清楚C++的大致框架后，可以读一读C++沉思录，这本书介绍的是一些C++思想，有助于你更好的理解。后期实战可以读一读Effecitve C++、More Effective C++，如果想深入了解C++底层机制的话，那么深度探索C++对象模型一定值得细细评味。 关于C++对象 C++对象模式在C++中，有两种类数据成员：静态数据成员(static关键词修饰)和非静态数据成员(没有static关键词修饰)，三种类成员函数：static、non-static、virtual。以下程序为例: 12345678910class Point&#123;public: int x; int y; Point(int _x, int _y); virtual ~Point(); int X() const;&#125;;Point point; 我创建了一个Point的对象，那么这个对象point的data member和funtion member是怎么布局呢? 简单对象模型这个模型是简单的一个模型，每个对象抽象成一些列的slots，每个slot对应一个成员，这样一来实现了member的对号入座。这样简化了编译器的设计复杂度，但是牺牲了效率和空间。在这个模型下，members本身不在object中，而是指向members的指针存放在object中，避免了*”members有不同的数据类型，因而需要不同的储存空间”。如此，object中的member便是通过slots的索引值来索引的。但是这个模型并**没有***被C++所采用，不过这个观念被应用到了指向成员的指针(pointer-to-member)这一概念之中。 表格驱动摸模型这个模型是把members划分为两类，datas放在data member table中，functions放在member function table中，object本身含有指向这两个表格的指针。data member table直接指向data本身，function member table是一系列的slots，每个slots指出一个member function。很遗憾，这个模型也没有被采用。但是member funciton table这一观念却支持了virtual function的机制。 C++对象模型这是Stroustrup设计C++时采用的模型。在这个模型之下，所有的non-static members都被置于每一个class object之中，static data members则被存放在这个class中(原书说法是存放在个别的class object之外)，static和non-static function members也被存放在个别的class object之外。而virtual functions分两步处理: 每一个class都会产生一系列指向virtual functions的指针，这些指针存放在一个叫virtual table(vtbl)的表格之中 每一个class object都会被”安排”一个指向这个class的vtbl的指针(vptr)，vptr的设置和重置由类的构造函数、拷贝构造函数、析构函数完成。(这里先不讨论)每个class还会关联一个type info object,由vtbl指出来，通常放在vtbl的第一个slots的位置()。 关键词的差异(class和struct)struct即结构，class即我们所说的类。C++为了兼容C，仍然保留了C的struct关键字，作为一种数据类型。 区别(简单理解) struct默认访问限制和继承方式是public，并且C++中struct类型中也可以拥有构造函数这点我在代码中有遇到过，一般用到struct的是一些比较操作，用于STL容器的sort()函数。如下示例程序: 123456789class A &#123; struct cmp&#123; int a; int b; bool operator()(int lhs, int rhs) &#123; return lhs &gt; rhs; &#125;; &#125;;&#125;; class默认访问限制是private 何时该用struct我觉得都可以，在C++中可以将两者等同，如果你愿意使用struct的话。 对象的差异C++程序设计模型直接支持以下三种程序设计范式： 程序模型(procedural model) 抽象数据类型模式(abstract data type model) 面向对象模型(object-oriented model) 杂谈 关于指针 一个指针或引用，无论其指向哪种数据类型，其本身所占内存大小是固定的。指针的类型，“指向不同的类型的指针”之间的差异，不在于指针的表示方法不同，也不在于指针的内容(地址)的不同，而是在于由这个指针所寻址出来的object类型的不同。也就是说，指针类型会让编译器以相应的方式去解释特定地址中的内容及大小。 一个指向地址100０的int类型的指针，在32位机器上，其所占的地址空间为1000~1003，因为32位机器上int类型所占４个字节(byte)。 那么一个指向地址1000的void*类型的指针呢？我们不知道，这也是为什么一个void*的类型的指针只能持有一个地址，不能操作其所指的对象的原因。 这里可以学习一下C++的四种cast。其本质是，只影响被指出的内存的大小和内容，不改变指针所指向的真正地址。 日后再补充。 写在后面C++真是一门magic的语言，究其本质，晦涩而又有点魅力，加油吧。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++对象</tag>
        <tag>对象模型</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo配置gitalk评论插件]]></title>
    <url>%2Fhexo%E9%85%8D%E7%BD%AEgitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6.html</url>
    <content type="text"><![CDATA[之前用的一直是来比力，不知为何加载很慢，而且社区版没有邮件登录的选项，比较不方便，于是乎，改成了gitalk，基于github issue的评论插件。原理是，创建一个用来存放comment的repo，将所有的comment都放在特定的issue下。 写在前面官方repo 创建OAuth application创建一个github OAuth application，点击这里，点进去如下： Application name: 随便写 Homepage url: 写你的博客主页url Application description: 应用的描述 Authorization callback url: 回调url，写你的博客url 如果你有自己的custom domain，写自己的域名 创建一个github repo这个很简单，一个空的public的repo就行，先创在这。私有仓库不知道行不行，貌似更加隐私 配置hexo配置文件以next主题为例，其他主题可能有所差别 新建gittalk.swig文件 路径: themes/next/layout/_third-party/comments/ 文件内容: 12345678910111213141516 &lt;!-- gitalk 评论系统 2019.8.19 --&gt;&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125; &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; const gitalk = new Gitalk(&#123; clientID: '&#123;&#123;theme.gitalk.clientID&#125;&#125;', clientSecret: '&#123;&#123;theme.gitalk.clientSecret&#125;&#125;', repo: '&#123;&#123;theme.gitalk.repo&#125;&#125;', owner: '&#123;&#123;theme.gitalk.githubID&#125;&#125;', admin: ['&#123;&#123;theme.gitalk.adminUser&#125;&#125;'], // 注意使用列表 id: location.pathname, // 依据官方readme,这里可能会有bug, post lable长度超过50会有报错 &#125;) gitalk.render('gitalk-container') &lt;/script&gt;&#123;% endif %&#125; 修改index.swig文件 路径: themes/next/layout/_third-party/comments/ 修改内容:在文件最后一行追加下列语句: 1&#123;% include 'gitalk.swig' %&#125; 修改comment.swig文件 路径: /themes/next/layout/_partials/ 修改内容: 12345678910 &#123;% elseif theme.valine.appid and theme.valine.appkey %&#125;&lt;div class="comments" id="comments"&gt;&lt;/div&gt; // 在这一行的下一行开始加 &#123;% elseif theme.gitalk.enable %&#125; // 加入以下三行&lt;div class="comments" id="comments"&gt;&lt;div id="gitalk-container"&gt;&lt;/div&gt; &#123;% endif %&#125;&#123;% endif %&#125; 修改主题配置文件_config.yml 文件路径: /themes/ 修改内容: 123456789101112 #gitalk评论gitalk: enable: true githubID: github用户名 repo: 用来存放comment的repo clientID: 你的clientID clientSecret: 你的clientSecret adminUser: admin用户，只有admin才可以init issue perPage: 15 pagerDirection: last createIssueManually: false distractionFreeMode: false 测试hexo clean hexo g hexo d 最终结果 踩过的坑 comment.swig文件配置错误，注意所加代码的位置 OAuth application创建有错误，按以上做法即可 粗心、大小写、配置文件写错 写在后面不知道为什么在hexo中markdown会解析奇怪的东西，比如说我写了`&lt;!–￼4–&gt;`这个东西，在hexo g的过程中，会报错，很奇怪的错误。后来把这个post删除了，再生成就没有问题了，所以说，可以确定这个问题是出在我刚刚写的.md文件内容导致的。 解决步骤 删除所有代码块，错误消失，还原所有内容 删除`&lt;!–￼5–&gt;`这个内容，错误消失至此，可以知道，问题就出在`&lt;!–￼6–&gt;`这段内容里，后来改成```包含的代码块就没有问题。所以说，遇到\{\%这样的字符需要转义，否则会被md解析。TODO这里还要深入了解一下md的解析原理]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>评论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java web--学习开篇]]></title>
    <url>%2Fjava%20web%20%E5%AD%A6%E4%B9%A0%E5%BC%80%E7%AF%87.html</url>
    <content type="text"><![CDATA[写在前面以前其实挺看不上前端coder的(该死的程序员鄙视链: C++ &gt; C &gt; JAVA &gt; PHP &gt; HTML …)，究其原因，我个人认为，做C++的，以后可很自豪的说： 我是做C++的。可是，我们真的懂C++了吗？这要看我们对懂的定义了，你要说我会用C++开发一个坦克大战，我会用C++开发一个管理系统，我会用C++，我懂C++了。这样其实也没错，可是C++这门特殊的语言，它所表现的并不只是面向对象的特性。业界有句话说的C++: 你永远不知道C++编译器背着你干了哪些事。这句话其实我很认同。例如: 默认构造函数在什么情况下编译器会为我们提供？ 答案是： 在程序员没有自己定义构造函数的时候，编译器会为我们提供一个默认的无参的构造函数，一旦程序员定义了构造函数，默认的构造函数便不再被提供。 C++的虚函数机制是什么样的？ 就我所了解的，虚函数机制是靠虚函数表VTable和虚函数指针VPtr来实现的，VTable里存放了虚函数的函数地址…(移步侯捷大师译作深度探索C++对象模型) C++是一门Magic的语言，要想学好C++、用好C++，必须要掌握深层次的内容，作为一只野生程序员(姑且允许我自称为程序员)，我认为我是不懂C++的。要学好C++，时间成本很高，但是一旦有所领悟，才算是入门了C++，就直接可以作为饭碗。否则，只会搬起石头砸自己的脚。至于为什么要学习前端知识呢？ B/S模式向C/S模式转变的趋向 当下随着浏览器技术的不断发展和计算机硬件水平的不断提高，C/S模式(即客户端/服务端模式)已经不能满足用户的需求、或者说开发维护成本高，比如：动态交互、可移植性，这些C/S模式下都很难去实现 增加技术栈 俗话说技多不压身(何况”技“也不多)，目前只是简单学了C、C++、Python、JAVA，作为一名非科班coder，任重道远啊。再者，之前老师有找我做个一个互联网+的项目，由于缺少前端开发经验，虽然想接手，但是还是拒绝了老师。后来想想挺后悔的。于是乎，打算这个暑假进击JSP，目标是开发出一个web管理信息系统。 放弃C++，转向java? 真的是，越学越发现自己越菜。相比较于C++，JAVA更容易能够实现一些东西，估计以后自己会走JAVA方向的吧？当然C++也会持续挖掘的。 学习过程目前正在狂补知识，顺便实现一下配套的小demo，先写到这里，待实战遇到问题时，再更。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>jsp</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>上手教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之进制转换]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2.html</url>
    <content type="text"><![CDATA[栈的介绍 定义: 栈是一种数据结构，一种特殊的线性表 特点: 只允许在一端进行插入操作，另一端进行删除操作 元素满足先进后出原则，即先入栈的元素最后出栈 算法详解算法很简单，除Ｘ取余法，用栈来把余数存起来，再出栈即可上代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define maxsize 10typedef struct &#123; int data[maxsize]; int top;&#125;seqstack, *pseqstack;pseqstack init_stack()&#123; pseqstack s = (pseqstack)malloc(sizeof(seqstack)); if(s)&#123; s -&gt; top = -1; &#125; return s;&#125;void push_stack(pseqstack s, int e)&#123; if (!s || s -&gt; top &gt; maxsize -1)&#123; printf("入栈失败!\n"); //return 0; &#125; else&#123; s -&gt; top ++; /*一定要先把ＴＯＰ加一，否则top 原来是－１,导致第一个元素入栈失败(bug fixed!) */ s -&gt; data[s -&gt; top] = e; //return 1; &#125;&#125;int pop_stack(pseqstack s, int *x)&#123; if (!s || s -&gt; top == -1)&#123; printf("出栈失败!\n"); return -1; &#125; else&#123; *x = s -&gt; data[s -&gt; top]; s -&gt; top --; return *x; &#125;&#125;/* 输出栈的每一个元素 */void print_each(pseqstack s)&#123; int top0 = s-&gt;top; while(top0 != -1)&#123; printf("%d\n", s-&gt;data[top0]); top0 --; &#125; &#125;/*进制转换，x是十进制de 数，y 是待转换进制*/void transfer(pseqstack s, int x, int y)&#123; int res; /* 整除后不等于０， 执行循环 */ while(x != 0)&#123; push_stack(s, (x%y)); x = x / y; &#125; //printf("%d\n", s-&gt;top); /* 加上输出功能 */ while(s-&gt; top != -1)&#123; pop_stack(s, &amp;res); printf("%d", res); if (s-&gt;top == -1)&#123; printf("\n"); &#125; &#125; &#125;int main()&#123; int num; // 十进制数 int scale; // 要转换的进制数 printf("输入十进制数字，进制数: "); scanf("%d %d", &amp;num, &amp;scale); pseqstack S = init_stack(); transfer(S, num, scale); //print_each(S); &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>进制转化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之约瑟夫问题的求解]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98%E7%9A%84%E6%B1%82%E8%A7%A3.html</url>
    <content type="text"><![CDATA[问题介绍约瑟夫问题 求解方案 顺序表 循环链表(不带头节点)值得注意的是，其实两种方法都是利用了循环的结构，想象成一个时钟的表盘 顺序表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/* 约瑟夫问题的顺序表实现author: Qian Jipeng(C)date: 2019-3-21*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define maxsize 100typedef struct node&#123; int data[maxsize]; int length;&#125;SeqList, *PSeqList;/* 初始化 */PSeqList Init()&#123; PSeqList L; L = (PSeqList)malloc(sizeof(SeqList)); if (L)&#123; L-&gt;length = 0; &#125; return L; /* 返回顺序表指针 */&#125;/* 插入 */int InSeqList(PSeqList L, int i, int e)&#123; if(i &lt; 1 || i &gt; L-&gt;length+1 || L-&gt;length &gt;= maxsize)&#123; printf("插入失败!\n"); return 0; &#125; else&#123; int j; L-&gt;data[i-1] = e; for (j=L-&gt;length; j&gt;=i; j--)&#123; L-&gt;data[j] = L-&gt;data[j-1]; /* 依次往后移动 */ &#125; L-&gt;length ++; &#125; return 1;&#125;/* 删除 */int DelSeqList(PSeqList L, int i, int *x)&#123; if ( i &lt; 1 || i &gt; L-&gt;length)&#123; printf("删除位置不合法\n"); return 0; &#125; int j; int tmp; // 保存将被删除的元素 tmp = L-&gt;data[i-1]; for (j = i ; j &lt;= L-&gt;length; j++ )&#123; // 从第I 个开始往前移动一位 L-&gt;data[j-1] = L-&gt;data[j]; &#125; L-&gt;length --; //printf("删除第 %d 个位置元素 %d 成功！\n", i, tmp); return 1;&#125;// 功能函数 s 开始， 数到 m int yusefu_SeqList(PSeqList L, int s, int m)&#123; int x; int i; int s1; int w; // 保存删除的元素 if( L-&gt; length == 0)&#123; printf("表空!\n"); return 0; &#125; s1 = s -1; // 依次出去 for (i = L-&gt;length; i &gt; 0; i--)&#123; /* 关键步骤 */ s1 = (s1+m-1) % i; w = L -&gt; data[s1]; // 下标 s1, 是第s1+1 个元素！！！ DelSeqList(L, s1+1, &amp;x); printf("出列: %d\n", w); &#125; return 1;&#125;int main()&#123; int len; // 序列长度 int num[maxsize]; // 用来存输入的数 PSeqList L = (PSeqList)malloc(sizeof(SeqList)); printf("输入序列元素个数: "); scanf("%d", &amp;len); printf("输入约瑟夫序列(空格分开): "); // 依次插入 for (int l = 0; l &lt; len; l++ )&#123; scanf("%d", &amp;num[l]); InSeqList(L, l+1, num[l]); //printf(" %d ", num[l]); &#125; yusefu_SeqList(L, 2, 5); return 0;&#125; 2.循环链表 这里的循环链表是没有头结点的，为了操作方便，否则每每循环到头结点还要跳过这个头结点，我的做法是:1. 先把第一个元素放入第一个节点(即首元节点)，只有数据域，指针域置空2. 接着用个循环，创建剩下的单个节点，同样只有数据域3. 再把这些节点连接起来 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/* 约瑟夫问题的循环链表实现* author: Qian Jipeng(C)* date: 2019-3-24* version: 2.0(1.0 aborted for too complexed)*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/* node definition */typedef struct node&#123; int data; struct node * next;&#125;linklist;/* \brief: crate the linklist and do insert, return the first node's ptr \param: n -&gt;&gt; the size of the serises\return: the first node's ptr*//* creat the node in range(1, n)*/linklist * initLink(int n)&#123; linklist * head = (linklist*)malloc(sizeof(linklist)); /* the first node initionalized (not head node)*/ head-&gt;data = 1; head-&gt;next = NULL; /* a ptr to move through the list */ linklist * tmp = head; /* we satrt with the second node for a loop */ for (int i = 2; i &lt;= n; i ++) &#123; linklist * body = (linklist*)malloc(sizeof(linklist)); /* creat and init single node */ body -&gt; data = i; body -&gt; next = NULL; /* connect the single nodes together */ tmp -&gt; next = body; tmp = tmp -&gt; next; &#125; //printf("%d\n", tmp-&gt;data); /* now tmp is just the last node */ tmp -&gt; next = head; /*connect the head and the rear */ return head; /* by this method, we created a loop linklist */&#125;void yusefu(linklist * head,int k,int m)&#123; linklist * tail = head; //找到链表第一个结点的上一个结点，为删除操作做准备 while (tail -&gt; next != head) &#123; tail = tail -&gt; next; &#125; linklist * p = head; //找到编号为k的人(或者是第几个开始，可以改) while (p -&gt; data != k) &#123; tail = p; p = p-&gt;next; &#125; //从编号为k的人开始，只有符合p-&gt;next==p时，说明链表中除了p结点，所有编号都出列了， while (p -&gt; next != p) &#123; //找到从p报数1开始，报m的人，并且还要知道数m-1de人的位置tail，方便做删除操作。 for (int i = 1; i &lt; m; i ++) &#123; tail = p; p = p -&gt; next; &#125; tail-&gt;next=p-&gt;next;//从链表上将p结点去除 printf("%d \t",p -&gt; data); free(p); p = tail -&gt; next;//继续使用p指针指向出列编号的下一个编号 &#125; /* the last one */ printf("%d \n",p -&gt; data); free(p);&#125;int main() &#123; linklist * head=initLink(10); yusefu(head, 2, 5); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>约瑟夫问题</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之逆波兰式]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F.html</url>
    <content type="text"><![CDATA[学的数据结构，感觉掌握的不牢固，于是实现了一个demo 中缀表达式转换为后缀表达式并求值 算法思想:创建一个操作数栈，自左向右遍历后缀表达式，遇到一个操作数就入栈，遇到一个操作符就从栈中取出两个操作数进行当前计算，载把结果入栈，直到表达式末尾, 最后一个入栈的就是最终结果 先实现求值这一步吧，已知后缀表达式 转换这一环节待更新… 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define maxsize 100#define datatype inttypedef struct &#123; datatype data[maxsize]; int top; // top 指明当前栈顶元素的位置&#125; SeqStack, *PSeqStack;// 初始化顺序栈PSeqStack Init_SeqStack()&#123; PSeqStack S; S = (PSeqStack) malloc(sizeof(SeqStack)); //printf("%p\n", S); if (S) S -&gt; top = -1; // top 设为-1 (认为设定),表示空 return S; // 返回指向顺序栈的指针&#125;// 判断栈空int Empty_SeqStack(PSeqStack S)&#123; // 没有元素，空栈 if (S -&gt; top == -1) return 1; // 1 表示为空 return 0; &#125;// 入栈void Push_SeqStack(PSeqStack S, datatype x)&#123; if (S -&gt; top == maxsize-1)&#123; printf("栈满不能再入栈\n"); //return 0; // 返回 0 表示失败 &#125; else&#123; S -&gt; top ++; S -&gt; data[S -&gt; top] = x; //return 1; &#125;&#125;// 出栈,保存栈顶元素于*x中，并删除void Pop_SeqStack(PSeqStack S, datatype *x)&#123; if (Empty_SeqStack(S))&#123; printf("栈空不能出栈\n"); //return 0; // 0 表示出栈失败 &#125; else&#123; *x = S -&gt; data[S -&gt; top]; S -&gt; top --; //return 1; &#125;&#125;// 取栈顶元素，只是获取他的值并存入*x，并没有取出来(删除),注意区别int GetTop_SeqStack(PSeqStack S, datatype *x)&#123; if (Empty_SeqStack(S))&#123; printf("栈空不能取top元素\n"); return 0; &#125; else&#123; *x = S -&gt; data[S -&gt; top]; return 1; &#125;&#125;// 销毁栈，参数为待销毁顺序栈的指针地址void Destory_SeqStack(PSeqStack *S)&#123; // *S 二级指针 if (*S) free (*S); *S = NULL; return;&#125;/* 判断是否是操作数 */int IsNum(char c)&#123; if (c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; return 1; &#125; return 0;&#125;char transfer()&#123; &#125;/* 核心函数 */int calculate(char *A)&#123; PSeqStack s = Init_SeqStack(); int result; int a, b, c; // a,b 上一次，上上一次入栈的元素，Ｃ是临时变量 char ch; ch = *A ++; /* 我们人为设置，在字符数组末尾加一个'#', 作为结束符 */ while(ch != '#')&#123; if (IsNum(ch))&#123; Push_SeqStack(s, ch - '0'); &#125; else &#123; /* 这里注意， 先进后出 */ Pop_SeqStack(s, &amp;b); Pop_SeqStack(s, &amp;a); switch (ch) &#123; case '+': c = a+b; break; case '-': c = a-b; break; case '*': c = a*b; break; case '/': c = a/b; break; default: break; &#125; /* 临时结果入栈 */ Push_SeqStack(s, c); &#125; ch = *A ++; &#125; GetTop_SeqStack(s, &amp;result); Destory_SeqStack(&amp;s); return result;&#125;int main()&#123; char num[12] = &#123;'1','2','8','5','-','*','+','4','2','/','-', '#'&#125;; printf("计算结果: %d\n",calculate(num)); return 0;&#125; 测试输入: 1char num[12] = &#123;'1','2','8','5','-','*','+','4','2','/','-', '#'&#125;; 测试结果: 15 写在最后其实，习惯了用C++的STL容器，我在平时的coding中很少会自己去创建一些数据结构，要排序会有std::sort()函数，而且STL容器的算法复杂度要远比单一数据结构算法复杂度要小的多，就拿排序来说，他用的可不止一种排序算法，不信这个有时间咱们可以验证…我学数据结构最大的收获就是： 学会用计算机的思维去思考问题 学会如何调试程序 学会耐心做一件事课程设计]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>逆波兰式</tag>
        <tag>堆栈</tag>
        <tag>中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统下文件乱码问题解决]]></title>
    <url>%2FLinux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%96%87%E4%BB%B6%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3-1.html</url>
    <content type="text"><![CDATA[今天在github上clone了一个master，想拿来练手，无奈是Windows下的编码，中文乱码，英文OK。于是想到之前看过一篇帖子，记录如下。 主要是用到了Linux的 iconv 命令 Step one 获取当前文件编码我当前文件是 Student.cpp 1file Student.cpp 得到输出如下： 1Student.cpp: C source, UTF-8 Unicode text 是个万国码 Step Two 获取本机编码1cat /etc/sysconfig/i18n 不知道为什么我这里报错，没有这个文件???不过Linux一般都是UTF-8 Step Three 修改文件编码1iconv -f GBK -t UTF-8 Student.cpp -o Student0.cpp 这里Student.cpp是原来的文件，Student0.cpp是我修改后的文件。 改后打开文件就没有乱码问题了 这里有个问题，如果有多个文件不能在一起转化比如我有两个文件，Student.cpp 和 Student.h 必须要执行两次命令，尴尬。后来想起来可以用通配符，文件名不改变，即可 注意： 通配符要慎用! 最后的最后: 写了个小项目，放在了仓库中编码转换]]></content>
      <categories>
        <category>utils</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>编码</tag>
        <tag>shell</tag>
      </tags>
  </entry>
</search>
