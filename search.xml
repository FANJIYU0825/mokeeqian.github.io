<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++对象模型--构造函数]]></title>
    <url>%2F2019%2F08%2F30%2FC-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[C++对象模型–构造函数这篇文章主要讲解C++中构造函数的机制，长篇文章，话不多说，开干！ Content1. 默认构造函数(Default Constructor)2. 拷贝构造函数(Copy Constructor)3. 程序转化(Programe Tansformation)4. 成员初始化列表(Member Initialization List) 1. 默认构造函数错误的、不全面的认识： + 如果程序员没有定义默认的构造函数，那么编译器就会提供一个默认构造函数，来完成对成员的初始化 + 编译器合成出来的默认构造函数会明确的设置类的每个数据成员的值正确认识： + 对于class X，如果没有任何user-defined constructor，那么会有一个默认构造函数会被隐式声明出来，这个构造函数是无用的 + 对构造函数的需求分为程序需求和编译器需求 + 一个有用的默认构造函数在必要的时候(4种情况下)也会被编译器合成 + + 1.1 何谓默认构造函数 C++ Annotated Reference Manual(ARM)中提及到：“default constrcutor在需要的时候会被编译器产生出来。” 那这里问题来了，“在需要的时候”，到底是什么时候？又是被谁需要？用来做什么事情？以下代码为例： 123456789101112class Foo &#123;public: int val; Foo *pnext;&#125;;void foo_bar() &#123; Foo bar; if ( bar.val || bar.pnext ) &#123; // do something &#125;&#125; 在这个程序中，要求val 和 pnext都必须被初始化为0，那么代码中并没有提供setter函数，只有通过和构造函数来初始化，但是代码也没有(显式)提供构造函数。那么这个情形是否符合上述的“在需要的时候”？答案当然是：NO。对“在需要的时候”，可以分为程序需要和编译器需要，至于前者，那是我们程序员自己的事，我们需要，那我们就自己写构造；后者，是编译器的工作。那么本例中的当然是程序需要，提供默认构造函数的责任就在于程序员。所以上述程序不会生成一个默认构造函数。 那么，什么时候才会合成一个默认构造函数？当编译器需要的时候！被合成出来的默认构造函数执行编译器所需要的行为(想想都很可怕，我们都不知编译器到底在背后做了什么)，因此，即便编译器为程序合成了一个默认构造函数，这个构造函数也不会执行我们希望的操作，就是说，这个Foo()构造函数不会把val和pnext都初始化为0，也就是我们所说的编译器合成的无用的默认构造函数(trivial)，C++ Standard[ISO-C++95]中的原话是，“对于class X，如果没有任何user-defined constructor，那么会有一个default constructor会被隐式声明出来，一个隐式声明出来的defalut constructor是一个trivial constructor”。 我们验证一下： 代码A： 123456789101112131415161718#include &lt;iostream&gt;using namespace std;class Foo &#123;public: int val; Foo *pnext;&#125;;void Foo_bar() &#123; Foo bar; cout &lt;&lt; bar.val &lt;&lt; endl; cout &lt;&lt; bar.pnext &lt;&lt; endl; &#125;int main() &#123; Foo_bar(); return 0;&#125; g++编译运行结果： 1241966240x400770 clang++编译运行结果： 1200 初步怀疑，与编译器有关？ g++编译gdb调试： 1$1 = &#123;val = 4196624, pnext = 0x400770 &lt;_start&gt;&#125; clang++编译gdb调试： 1$2 = &#123;val = 0, pnext = 0x0&#125; 另外，在线编译器爆出了一个warnning: 123456789101112Startprog.cc: In function 'void Foo_bar()':prog.cc:11:14: warning: 'bar.Foo::val' is used uninitialized in this function [-Wuninitialized] 11 | cout &lt;&lt; bar.val &lt;&lt; endl; | ^~~prog.cc:12:17: warning: 'bar.Foo::pnext' may be used uninitialized in this function [-Wmaybe-uninitialized] 12 | cout &lt;&lt; bar.pnext &lt;&lt; endl; | ~~~~^~~~~41977920x400c200Finish 意思是val和pnext没有被初始化，这就说明了我们的无用的默认构造函数没有对类成员进行初始化，在这里，貌似要解释一下初始化和赋值 代码B： 12345678910111213141516#include &lt;iostream&gt;using namespace std;class Foo &#123;public: int val; Foo *pnext;&#125;;void Foo_bar() &#123; Foo bar;&#125;int main() &#123; Foo_bar(); return 0;&#125; g++编译，gdb调试结果： 1$1 = &#123;val = 4196128, pnext = 0x4005c0 &lt;_start&gt;&#125; 可见，这里的val = 4196128, 貌似是一个随机生成的数值。 clang++编译，gdb调试结果：1$1 = &#123;val = 0, pnext = 0x0&#125; 此上，基本可以推断出，默认构造函数的行为貌似与编译器有关？但是可以肯定的是， 1.2 trivial默认构造函数1.2.1 何时合成1.2.2 做哪些事1.3 non-trivial默认构造函数1.3.1 何时合成1.3.2 做那些事]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>对象模型</tag>
        <tag>C++</tag>
        <tag>构造函数</tag>
        <tag>拷贝构造函数</tag>
        <tag>默认构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP(一)--计算机系统漫游]]></title>
    <url>%2F2019%2F08%2F29%2FCSAPP-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8%2F</url>
    <content type="text"><![CDATA[计算机系统学习狂补知识ing… 计算机系统计算机系统是由计算机硬件和系统软件组成的，它们共同工作来与进行应用程序。接下来，我会以hello.c为例，进行一些零散的总结。 12345#include &lt;stdio.h&gt;int main() &#123; printf("Hello World!\n"); return 0;&#125; 信息信息就是位+上下文，我们的hello.c文件叫源文件、源程序，实际上就是一个由值0和1组成的位序列，叫比特(bit)，8个位被组织成一组，成为一个字节(byte)，每个字节表示程序中的某些文本字符，现在大部分的计算机都使用ANSII标准来存储字符，每个字符都对应唯一的单字节大小的整数值，叫ANSII值。 编译系统目前的C、C++、Pascal等都是高级语言，汇编语言也是一些汇编指令，只有最低级的机器指令(0、１序列)才能够被计算机直接“识别”，所以说，要想运行一串高级语言代码，必须要有一样东西，把这些高级语言代码转换为计算机能够直接识别的机器指令，这就是编译器的作用。一个计算机编译系统，由四部分组成： 预处理器(ccp) 编译器(ccl) 汇编器(as) 链接器(ld)相应的，一个程序的编译过程，也分为四个阶段： 预处理阶段预处理器会扫描源文件，定位到以”#”开头的内容，根据这个内容，修改源文件的内容，比如说前面#include &lt;stdio.h&gt;，这时候，我就要找到stdio.h这个头文件，把这个头文件的内容直接插入到hello.c源文件中(至于具体在哪个位置，我们不知道)，生成新的源文件hello.i，通常以.i作为文件扩展名。 编译阶段编译器会将文本文件hello.i翻译成文本文件hello.s，它包含了一个汇编语言程序，。即将高级语言翻译成汇编语言。的汇编程序可以为不同的高级语言和不同的编译器提供通用的输出语言。gcc -S hello.s hello.c 汇编阶段汇编器将汇编语言翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，将结果放在hello.o这个二进制文件中。gcc -c hello.o hello.c 链接阶段我们的hell.o调用了stdio的printf()函数，它是C语言的一个标准库函数，位于printf.o这个独立的预编译好了的目标文件中，必须要加入我们的hello.o文件中，程序才能够正常运行。链接器就是做这个工作的，将printf.o文件与hello.o文件链接，得到hello可执行目标文件，当然，也是二进制文件。这个可执行目标文件可以加载到内存中，被计算机所执行。gcc -o hello hello.c 这样的命令会生成可执行文件hello，一般没有后缀。 了解编译系统的工作流程带来的好处： 优化程序性能比如说，switch就会比if效率高吗？while和for的效率问题，函数调用的开销到底有多大，传指针和传值到底有什么区别？这些目前我还不清楚、或者说不太清楚，所知道的也就是从书上、网上学来的。或许学了程序的编译过程，就会明白了把。 理解链接时的错误写代码时，经常会遇到链接错误，顺带提一下，动态链接和静态链接，待学习。 动态链接和静态链接1. 动态链接 Windows: .lib文件 Linux: .a文件 函数库的一份拷贝是可执行文件的物理组成部分，称之为静态链接。静态链接当链接程序时，需要使用的每个库函数的一份拷贝被加入到可执行文件中。静态链接使用静态库进行链接，生成的程序包含程序运行所需要的全部库，可以直接运行，不过静态链接生成的程序体积较大（即使是在静态链接中，整个库文件也并没有全部装入到可执行文件中，所装入的只是需要的函数）。2. 静态链接 Windows: .dll文件 Linux: .so文件 如果可执行文件只是包含了文件名，让载入器在运行时能够寻找程序所需要的函数库，称之为动态链接。动态链接允许系统提供一个庞大的函数库集合，可以提供许多有用的服务，程序在运行时寻找它们。动态链接使用动态链接库进行链接，生成的程序在执行的时候需要加载所需的动态库才能运行。动态链接生成的程序体积较小，但是必须依赖所需的动态库，否则无法执行。3. 细节 gcc编译器默认使用动态编译，如果要指定静态编译，需要加上-static参数]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
        <tag>动态链接</tag>
        <tag>静态链接</tag>
        <tag>编译系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机系统基础--学习开篇]]></title>
    <url>%2F2019%2F08%2F24%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E5%BC%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[写在前面 作为一个非科班出身的半吊子程序员(程序员?)，在和计算机专业的同学交流的过程中，切实感受到知识面的匮乏，总体体现在对计算机系统的理解。确实，作为一名双非院校信管专业的学生，本身起步就比别人慢了不少，若没有扎实的基本功，将来怎么与别人竞争。 在自学了将近一年的代码之后，随着代码量的增加，越发觉得基础知识的匮乏，对指针理解的不够透彻，对程序代码的执行情况也是一知半解。不过也不失为一件好事，最怕的就是发现不了问题，故开设这篇博客，记录下以后学习的过程。先给自己定个学习路线吧: 计算机系统基础NJU袁春凤 + MOOC，为期一个学期，势必拿下 CSAPP 我的计算机学习之路 要说我真正的计算机学习之路，是我的导师领我进门的。是从学Python代码开始的，虽然大一下开的C，当时也只是记住了一些计算机常识，并没有过多的去重视，后来时间到了大二，一天我的导师找到我，问了我有没有兴趣搞代码。在这里顺便啰嗦一下，给我的学弟学妹们吧。 信管专业，是个交叉学科，学的东西多且复杂，简单的来说是计算机学科知识也管理科学相交叉的产物。在这个大环境下，如果没有明确的目标，那么四年后你将一事无成。所以，在大一下，对自己的专业有了一定的认识之后，就应该明确自己以后的学习方向，是搞代码还是搞管理，还是搞测试，还是搞其他的，最晚最晚大二上也要定好方向了。这里我假设你选择的是技术路线，无论你是搞运维还是搞开发还是搞测试，总之都得与代码打交道。所有你就要在平时学习中多动手，多动脑。但是问题来了，我的专业是分在管院，顾名思义，侧重的是管理科学，所以如果想做技术的话，要下狠功夫，狠补计算机相关知识。其实我觉得可以先学着一两门编程语言，在学习的过程中，你会发现自己专业知识的缺乏，有的时候一些问题会感觉无从下手，这个时候，你已经有了一定的编程基础(注意编程能力和项目能力的区别)，带着问题和目的的取学习一样东西往往是最高效的。 我还是很菜，虽然有一些Linux开发经验，但是对于Linux系统底层的机制还是不懂，是完全不懂啊。先前试着看了Linux内核源码，无奈看不懂。。也是，没有计算机系统基础知识，怎么能读它。所以说，要学好计算机，就必须先要把入门课补回来。出来混总是要还的～～ ps: 编程能力侧重动脑能力，指的是完成小程序、算法相关的能力，pta,leetcode… 项目能力侧重动手能力，要求能够合理使用现有资源(API、框架…)开发出一个完整的项目，例如：管理系统，坦克大战… 学习之路先看着南大的MOOC学习，它是根据CSAPP改编而来，我看了一下感觉挺好，容易理解。未完待续…]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
        <tag>CS</tag>
        <tag>学习生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web--浅谈jsp与servlet]]></title>
    <url>%2F2019%2F08%2F23%2Fweb-%E6%B5%85%E8%B0%88jsp%E4%B8%8Eservlet%2F</url>
    <content type="text"><![CDATA[JSP和servlet区别 jsp的本质就是servlet，jsp经过编译后会转化成servlet因为jvm只能识别java类，不能识别其他的类文件，所以就有了一系列的web容器(服务器)，如tomcat，这些容器将jsp编译成jvm能够识别的java类 一般来说，jsp用于页面展示，servlet用于逻辑控制比如说要实现一个用户登录模块，我们会把页面显示交给jsp，内部逻辑控制交给servlet servlet没有内置对象，jsp有一些内置对象 联系 servlet是严格意义上的java类，它在MVC模型中是控制层，它与表现层完全分离 jsp可以是html标签，可以嵌入java代码，它是表现层，侧重于视图 做好理解 不同之处servlet通过java代码httpServletResponse对象向客户端动态输出html内容，就是说，如果我要在servlet中向客户端输出或者展示一些东西，必须要以html标签的形式 各自特点servlet可以很好的组织业务逻辑，但是通过以字符串的形式向客户端传送html标签使得代码维护起来比较困难。但是一概的在jsp里面混入大量的业务逻辑也是不可取的。 如何均衡那么如何做到二者的优势互补？答案当然是MVC，MVC是一种软件架构，分为: 模型层(Model)—业务逻辑 视图层(View)—负责页面显示 控制层(Controler)—负责相关交互操作 示例demo这个小demo主要实现了html表单的用户登录操作，然后记录用户的提交信息，返回给客户端。 1. loginServlet.java 12345678910111213141516171819202122232425262728293031323334353637383940package servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(urlPatterns = "/login", name = "login")/** * 这里是 servlet负责页面显示， 也可以是SERVLET负责数据处理, jsp 负责页面显示 */public class LoginServlet extends HttpServlet &#123; public static final long serialVersionUID = 1L; public LoginServlet() &#123; super(); &#125; // post 提交浏览器不会显示，比较安全 protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 设置页面编码格式 request.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=UTF-8"); String user = request.getParameter("user"); // 这样写是没有效果的，servlet向浏览器输出内容，浏览器只能解析html,所以要用html标签向页面传送信息 //response.getWriter().println(user); //response.getWriter().print("这是登录界面"); // response.getWriter() 获得一个输出流 String string = "&lt;html&gt; &lt;head&gt; &lt;title&gt;这是servlet返回的结果&lt;/title&gt;&lt;/head&gt; &lt;body&gt; 欢迎 " + user + "&lt;/body&gt; &lt;/html&gt;"; response.getWriter().print(string); &#125;&#125; 2. login.jsp 1234567891011121314151617181920212223242526&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;servlet测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="login" method="post"&gt; &lt;table&gt; &lt;tb&gt; uesr: &lt;input type="text" name="user"&gt; &lt;br&gt; &lt;/tb&gt; &lt;tb&gt; passwd: &lt;input type="password" name="passwd"&gt; &lt;br&gt; &lt;/tb&gt; &lt;/table&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 测试结果可以知道，我输入的user是“servler测试”，点击登录按钮后，返回给客户端的就是用户提交的user值，”servlet测试“。 页面提交 信息返回]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>jsp</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java web--servlet学习]]></title>
    <url>%2F2019%2F08%2F22%2Fservlet%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[接上篇，学习servlet基础。 servlet是什么java servlet是运行在web服务器上的应用程序，实现动态页面的创建，作为来自web浏览器和其他http客户端请求和http服务器上的数据库或者应用程序之间的中间层。 http请求和响应过程 servlet架构 架构 tomcat与servlet 这里可以知道，tomcat将浏览器发过来的http请求(http request)文本接收并解析，封装成httpServlet类型的request对象 tomcat服务器同时将要响应的信息封装成httpResponse类型的response对象，通过设置response的相关属性就可以控制输出到浏览器的内容，再将response交给tomcat，tomcat就会将其转换成要响应的文本格式返回给浏览器 servlet任务 读取客户端发送的显式数据，包括html表单，或者是applet或者用户定义程序的表单 读取客户端发送的隐式http请求，包括cookies等 处理数据并获得结果，可能会访问数据库调用web服务 发送显式的数据到客户端，可能是文档、图片等 发送隐式的http响应到客户端 java servlet包java servlet是运行在带有servlet解释器的web服务器(我用的是tomcat)上的java类。通常需要import javax.servlet.*来导入包。java servlet API 是servlet容器(tomcat为例)和servlet之间的接口，定义了各种servlet方法，和一些对象，其中主要是servletRequest和servletResponse对象比较重要。 编写servlet编写servlet有两种方法： 直接编写servlet类，实现相应的方法这个方法需要编写完整的java类，比较复杂，而且容易出错。故我们采用第二种方法。 用IDE(我的是idea)新建myServlet新建myServlet，默认会实现doGet()和doPost()方法，也可以根据自己的需要，实现其他方法，诸如：init()、service()、destory() 另外，要实现与jsp的交互，必须要配置web.xml文件，写入servlet、servlet-mapping等标签，除此之外，也可以在servlet类的添加注释(annoation)，例如： @WebServlet(urlPatterns = &quot;/signin&quot;, name = &quot;signin&quot;)，这样就可以不用配置web.xml文件 详解servlet原理1. servlet生命周期 servlet的生命周期始于servlet服务器启动时或者第一次请求该servlet，此时调用init()方法，初始化出一个servlet对象 servlet处理所有的客户端请求，执行service()方法 服务器关闭，执行destory()方法，servlet被销毁 2. servlet的service()方法这里有个问题，我们在编写servlet时，只写了doPost()和doGet()方法，并没有写service()方法，那么servlet是如何执行service()方法的呢？public的service()方法，这是对外的公有方法，这里做了一个ServletRequest到httpServletRequest的转型 内部的protected的方法，根据请求的方法method不同，调用不同的响应方式： 也就是说，service()方法一般情况下我们是不需要重写的，它已经包括的所有的推理机，我们只要重写相应需要的方法就行了，比如说doPost()、doGet()，这也是idea默认给我们重写的两个方法。3. servlet重要的对象servlet为我们创建了几个内置对象： servletCopnfig servletContext httpServletRequest httpServletResponse]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++对象模型--关于对象]]></title>
    <url>%2F2019%2F08%2F22%2FC%2B%2B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B--%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[写在前面为什么要写C++一栏的博客呢?其实是为了加深理解和敦促学习，我发现只要离开写博客，人就变得懒散起来，每天写的代码零零散散，C++这门课程是在大二上开的，上课也就水水过去了，老师上课其实也还挺好，无奈听不懂啊，听不懂就不想听啊。现在想想挺后悔的。后来由于实验室需要，而且自己也意识到C++的重要性，于是便自学。(貌似我所有的编程语言都是自学的、除了大一的C)至于自学，我的做法是，找博客，一个一个知识点地去学，后来也勉强算是入门了把。好记性不如烂笔头，于是还是记录下来比较好。 关于入门入门书籍的选取太重要了。谁要是和你推荐诸如21天学通C++、Visual C++ xxx的，可以绝交了(滑稽)，我推荐C++ primer而不是C++ primer plus，不是带了个plus就是更牛x一点，相反，plus对于新入门的来说，讲的太过细致，有点晦涩，以至于你想放弃。搞清楚C++的大致框架后，可以读一读C++沉思录，这本书介绍的是一些C++思想，有助于你更好的理解。后期实战可以读一读Effecitve C++、More Effective C++，如果想深入了解C++底层机制的话，那么深度探索C++对象模型一定值得细细评味。 关于C++对象 C++对象模式在C++中，有两种类数据成员：静态数据成员(static关键词修饰)和非静态数据成员(没有static关键词修饰)，三种类成员函数：static、non-static、virtual。以下程序为例: 12345678910class Point&#123;public: int x; int y; Point(int _x, int _y); virtual ~Point(); int X() const;&#125;;Point point; 我创建了一个Point的对象，那么这个对象point的data member和funtion member是怎么布局呢? 简单对象模型这个模型是简单的一个模型，每个对象抽象成一些列的slots，每个slot对应一个成员，这样一来实现了member的对号入座。这样简化了编译器的设计复杂度，但是牺牲了效率和空间。在这个模型下，members本身不在object中，而是指向members的指针存放在object中，避免了*”members有不同的数据类型，因而需要不同的储存空间”。如此，object中的member便是通过slots的索引值来索引的。但是这个模型并**没有***被C++所采用，不过这个观念被应用到了指向成员的指针(pointer-to-member)这一概念之中。 表格驱动摸模型这个模型是把members划分为两类，datas放在data member table中，functions放在member function table中，object本身含有指向这两个表格的指针。data member table直接指向data本身，function member table是一系列的slots，每个slots指出一个member function。很遗憾，这个模型也没有被采用。但是member funciton table这一观念却支持了virtual function的机制。 C++对象模型这是Stroustrup设计C++时采用的模型。在这个模型之下，所有的non-static members都被置于每一个class object之中，static data members则被存放在这个class中(原书说法是存放在个别的class object之外)，static和non-static function members也被存放在个别的class object之外。而virtual functions分两步处理: 每一个class都会产生一系列指向virtual functions的指针，这些指针存放在一个叫virtual table(vtbl)的表格之中 每一个class object都会被”安排”一个指向这个class的vtbl的指针(vptr)，vptr的设置和重置由类的构造函数、拷贝构造函数、析构函数完成。(这里先不讨论)每个class还会关联一个type info object,由vtbl指出来，通常放在vtbl的第一个slots的位置()。 关键词的差异(class和struct)struct即结构，class即我们所说的类。C++为了兼容C，仍然保留了C的struct关键字，作为一种数据类型。 区别(简单理解) struct默认访问限制和继承方式是public，并且C++中struct类型中也可以拥有构造函数这点我在代码中有遇到过，一般用到struct的是一些比较操作，用于STL容器的sort()函数。如下示例程序: 123456789class A &#123; struct cmp&#123; int a; int b; bool operator()(int lhs, int rhs) &#123; return lhs &gt; rhs; &#125;; &#125;;&#125;; class默认访问限制是private 何时该用struct我觉得都可以，在C++中可以将两者等同，如果你愿意使用struct的话。 对象的差异C++程序设计模型直接支持以下三种程序设计范式： 程序模型(procedural model) 抽象数据类型模式(abstract data type model) 面向对象模型(object-oriented model) 杂谈 关于指针 一个指针或引用，无论其指向哪种数据类型，其本身所占内存大小是固定的。指针的类型，“指向不同的类型的指针”之间的差异，不在于指针的表示方法不同，也不在于指针的内容(地址)的不同，而是在于由这个指针所寻址出来的object类型的不同。也就是说，指针类型会让编译器以相应的方式去解释特定地址中的内容及大小。 一个指向地址100０的int类型的指针，在32位机器上，其所占的地址空间为1000~1003，因为32位机器上int类型所占４个字节(byte)。 那么一个指向地址1000的void*类型的指针呢？我们不知道，这也是为什么一个void*的类型的指针只能持有一个地址，不能操作其所指的对象的原因。 这里可以学习一下C++的四种cast。其本质是，只影响被指出的内存的大小和内容，不改变指针所指向的真正地址。 日后再补充。 写在后面C++真是一门magic的语言，究其本质，晦涩而又有点魅力，加油吧。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++对象</tag>
        <tag>对象模型</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo配置gitalk评论插件]]></title>
    <url>%2F2019%2F08%2F20%2Fhexo%E9%85%8D%E7%BD%AEgitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[之前用的一直是来比力，不知为何加载很慢，而且社区版没有邮件登录的选项，比较不方便，于是乎，改成了gitalk，基于github issue的评论插件。原理是，创建一个用来存放comment的repo，将所有的comment都放在特定的issue下。 写在前面官方repo 创建OAuth application创建一个github OAuth application，点击这里，点进去如下： Application name: 随便写 Homepage url: 写你的博客主页url Application description: 应用的描述 Authorization callback url: 回调url，写你的博客url 如果你有自己的custom domain，写自己的域名 创建一个github repo这个很简单，一个空的public的repo就行，先创在这。私有仓库不知道行不行，貌似更加隐私 配置hexo配置文件以next主题为例，其他主题可能有所差别 新建gittalk.swig文件 路径: themes/next/layout/_third-party/comments/ 文件内容: 12345678910111213141516 &lt;!-- gitalk 评论系统 2019.8.19 --&gt;&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125; &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; const gitalk = new Gitalk(&#123; clientID: '&#123;&#123;theme.gitalk.clientID&#125;&#125;', clientSecret: '&#123;&#123;theme.gitalk.clientSecret&#125;&#125;', repo: '&#123;&#123;theme.gitalk.repo&#125;&#125;', owner: '&#123;&#123;theme.gitalk.githubID&#125;&#125;', admin: ['&#123;&#123;theme.gitalk.adminUser&#125;&#125;'], // 注意使用列表 id: location.pathname, // 依据官方readme,这里可能会有bug, post lable长度超过50会有报错 &#125;) gitalk.render('gitalk-container') &lt;/script&gt;&#123;% endif %&#125; 修改index.swig文件 路径: themes/next/layout/_third-party/comments/ 修改内容:在文件最后一行追加下列语句: 1&#123;% include 'gitalk.swig' %&#125; 修改comment.swig文件 路径: /themes/next/layout/_partials/ 修改内容: 12345678910 &#123;% elseif theme.valine.appid and theme.valine.appkey %&#125;&lt;div class="comments" id="comments"&gt;&lt;/div&gt; // 在这一行的下一行开始加 &#123;% elseif theme.gitalk.enable %&#125; // 加入以下三行&lt;div class="comments" id="comments"&gt;&lt;div id="gitalk-container"&gt;&lt;/div&gt; &#123;% endif %&#125;&#123;% endif %&#125; 修改主题配置文件_config.yml 文件路径: /themes/ 修改内容: 123456789101112 #gitalk评论gitalk: enable: true githubID: github用户名 repo: 用来存放comment的repo clientID: 你的clientID clientSecret: 你的clientSecret adminUser: admin用户，只有admin才可以init issue perPage: 15 pagerDirection: last createIssueManually: false distractionFreeMode: false 测试hexo clean hexo g hexo d 最终结果 踩过的坑 comment.swig文件配置错误，注意所加代码的位置 OAuth application创建有错误，按以上做法即可 粗心、大小写、配置文件写错 写在后面不知道为什么在hexo中markdown会解析奇怪的东西，比如说我写了`&lt;!–￼4–&gt;`这个东西，在hexo g的过程中，会报错，很奇怪的错误。后来把这个post删除了，再生成就没有问题了，所以说，可以确定这个问题是出在我刚刚写的.md文件内容导致的。 解决步骤 删除所有代码块，错误消失，还原所有内容 删除`&lt;!–￼5–&gt;`这个内容，错误消失至此，可以知道，问题就出在`&lt;!–￼6–&gt;`这段内容里，后来改成```包含的代码块就没有问题。所以说，遇到\{\%这样的字符需要转义，否则会被md解析。TODO这里还要深入了解一下md的解析原理]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>评论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java web--学习开篇]]></title>
    <url>%2F2019%2F08%2F20%2Fjava%20web%20%E5%AD%A6%E4%B9%A0%E5%BC%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[写在前面以前其实挺看不上前端coder的(该死的程序员鄙视链: C++ &gt; C &gt; JAVA &gt; PHP &gt; HTML …)，究其原因，我个人认为，做C++的，以后可很自豪的说： 我是做C++的。可是，我们真的懂C++了吗？这要看我们对懂的定义了，你要说我会用C++开发一个坦克大战，我会用C++开发一个管理系统，我会用C++，我懂C++了。这样其实也没错，可是C++这门特殊的语言，它所表现的并不只是面向对象的特性。业界有句话说的C++: 你永远不知道C++编译器背着你干了哪些事。这句话其实我很认同。例如: 默认构造函数在什么情况下编译器会为我们提供？ 答案是： 在程序员没有自己定义构造函数的时候，编译器会为我们提供一个默认的无参的构造函数，一旦程序员定义了构造函数，默认的构造函数便不再被提供。 C++的虚函数机制是什么样的？ 就我所了解的，虚函数机制是靠虚函数表VTable和虚函数指针VPtr来实现的，VTable里存放了虚函数的函数地址…(移步侯捷大师译作深度探索C++对象模型) C++是一门Magic的语言，要想学好C++、用好C++，必须要掌握深层次的内容，作为一只野生程序员(姑且允许我自称为程序员)，我认为我是不懂C++的。要学好C++，时间成本很高，但是一旦有所领悟，才算是入门了C++，就直接可以作为饭碗。否则，只会搬起石头砸自己的脚。至于为什么要学习前端知识呢？ B/S模式向C/S模式转变的趋向 当下随着浏览器技术的不断发展和计算机硬件水平的不断提高，C/S模式(即客户端/服务端模式)已经不能满足用户的需求、或者说开发维护成本高，比如：动态交互、可移植性，这些C/S模式下都很难去实现 增加技术栈 俗话说技多不压身(何况”技“也不多)，目前只是简单学了C、C++、Python、JAVA，作为一名非科班coder，任重道远啊。再者，之前老师有找我做个一个互联网+的项目，由于缺少前端开发经验，虽然想接手，但是还是拒绝了老师。后来想想挺后悔的。于是乎，打算这个暑假进击JSP，目标是开发出一个web管理信息系统。 放弃C++，转向java? 真的是，越学越发现自己越菜。相比较于C++，JAVA更容易能够实现一些东西，估计以后自己会走JAVA方向的吧？当然C++也会持续挖掘的。 学习过程目前正在狂补知识，顺便实现一下配套的小demo，先写到这里，待实战遇到问题时，再更。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>jsp</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>上手教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之进制转换]]></title>
    <url>%2F2019%2F08%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[栈的介绍 定义: 栈是一种数据结构，一种特殊的线性表 特点: 只允许在一端进行插入操作，另一端进行删除操作 元素满足先进后出原则，即先入栈的元素最后出栈 算法详解算法很简单，除Ｘ取余法，用栈来把余数存起来，再出栈即可上代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define maxsize 10typedef struct &#123; int data[maxsize]; int top;&#125;seqstack, *pseqstack;pseqstack init_stack()&#123; pseqstack s = (pseqstack)malloc(sizeof(seqstack)); if(s)&#123; s -&gt; top = -1; &#125; return s;&#125;void push_stack(pseqstack s, int e)&#123; if (!s || s -&gt; top &gt; maxsize -1)&#123; printf("入栈失败!\n"); //return 0; &#125; else&#123; s -&gt; top ++; /*一定要先把ＴＯＰ加一，否则top 原来是－１,导致第一个元素入栈失败(bug fixed!) */ s -&gt; data[s -&gt; top] = e; //return 1; &#125;&#125;int pop_stack(pseqstack s, int *x)&#123; if (!s || s -&gt; top == -1)&#123; printf("出栈失败!\n"); return -1; &#125; else&#123; *x = s -&gt; data[s -&gt; top]; s -&gt; top --; return *x; &#125;&#125;/* 输出栈的每一个元素 */void print_each(pseqstack s)&#123; int top0 = s-&gt;top; while(top0 != -1)&#123; printf("%d\n", s-&gt;data[top0]); top0 --; &#125; &#125;/*进制转换，x是十进制de 数，y 是待转换进制*/void transfer(pseqstack s, int x, int y)&#123; int res; /* 整除后不等于０， 执行循环 */ while(x != 0)&#123; push_stack(s, (x%y)); x = x / y; &#125; //printf("%d\n", s-&gt;top); /* 加上输出功能 */ while(s-&gt; top != -1)&#123; pop_stack(s, &amp;res); printf("%d", res); if (s-&gt;top == -1)&#123; printf("\n"); &#125; &#125; &#125;int main()&#123; int num; // 十进制数 int scale; // 要转换的进制数 printf("输入十进制数字，进制数: "); scanf("%d %d", &amp;num, &amp;scale); pseqstack S = init_stack(); transfer(S, num, scale); //print_each(S); &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>进制转化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之约瑟夫问题的求解]]></title>
    <url>%2F2019%2F08%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98%E7%9A%84%E6%B1%82%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[问题介绍约瑟夫问题 求解方案 顺序表 循环链表(不带头节点)值得注意的是，其实两种方法都是利用了循环的结构，想象成一个时钟的表盘 顺序表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/* 约瑟夫问题的顺序表实现author: Qian Jipeng(C)date: 2019-3-21*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define maxsize 100typedef struct node&#123; int data[maxsize]; int length;&#125;SeqList, *PSeqList;/* 初始化 */PSeqList Init()&#123; PSeqList L; L = (PSeqList)malloc(sizeof(SeqList)); if (L)&#123; L-&gt;length = 0; &#125; return L; /* 返回顺序表指针 */&#125;/* 插入 */int InSeqList(PSeqList L, int i, int e)&#123; if(i &lt; 1 || i &gt; L-&gt;length+1 || L-&gt;length &gt;= maxsize)&#123; printf("插入失败!\n"); return 0; &#125; else&#123; int j; L-&gt;data[i-1] = e; for (j=L-&gt;length; j&gt;=i; j--)&#123; L-&gt;data[j] = L-&gt;data[j-1]; /* 依次往后移动 */ &#125; L-&gt;length ++; &#125; return 1;&#125;/* 删除 */int DelSeqList(PSeqList L, int i, int *x)&#123; if ( i &lt; 1 || i &gt; L-&gt;length)&#123; printf("删除位置不合法\n"); return 0; &#125; int j; int tmp; // 保存将被删除的元素 tmp = L-&gt;data[i-1]; for (j = i ; j &lt;= L-&gt;length; j++ )&#123; // 从第I 个开始往前移动一位 L-&gt;data[j-1] = L-&gt;data[j]; &#125; L-&gt;length --; //printf("删除第 %d 个位置元素 %d 成功！\n", i, tmp); return 1;&#125;// 功能函数 s 开始， 数到 m int yusefu_SeqList(PSeqList L, int s, int m)&#123; int x; int i; int s1; int w; // 保存删除的元素 if( L-&gt; length == 0)&#123; printf("表空!\n"); return 0; &#125; s1 = s -1; // 依次出去 for (i = L-&gt;length; i &gt; 0; i--)&#123; /* 关键步骤 */ s1 = (s1+m-1) % i; w = L -&gt; data[s1]; // 下标 s1, 是第s1+1 个元素！！！ DelSeqList(L, s1+1, &amp;x); printf("出列: %d\n", w); &#125; return 1;&#125;int main()&#123; int len; // 序列长度 int num[maxsize]; // 用来存输入的数 PSeqList L = (PSeqList)malloc(sizeof(SeqList)); printf("输入序列元素个数: "); scanf("%d", &amp;len); printf("输入约瑟夫序列(空格分开): "); // 依次插入 for (int l = 0; l &lt; len; l++ )&#123; scanf("%d", &amp;num[l]); InSeqList(L, l+1, num[l]); //printf(" %d ", num[l]); &#125; yusefu_SeqList(L, 2, 5); return 0;&#125; 2.循环链表 这里的循环链表是没有头结点的，为了操作方便，否则每每循环到头结点还要跳过这个头结点，我的做法是:1. 先把第一个元素放入第一个节点(即首元节点)，只有数据域，指针域置空2. 接着用个循环，创建剩下的单个节点，同样只有数据域3. 再把这些节点连接起来 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/* 约瑟夫问题的循环链表实现* author: Qian Jipeng(C)* date: 2019-3-24* version: 2.0(1.0 aborted for too complexed)*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/* node definition */typedef struct node&#123; int data; struct node * next;&#125;linklist;/* \brief: crate the linklist and do insert, return the first node's ptr \param: n -&gt;&gt; the size of the serises\return: the first node's ptr*//* creat the node in range(1, n)*/linklist * initLink(int n)&#123; linklist * head = (linklist*)malloc(sizeof(linklist)); /* the first node initionalized (not head node)*/ head-&gt;data = 1; head-&gt;next = NULL; /* a ptr to move through the list */ linklist * tmp = head; /* we satrt with the second node for a loop */ for (int i = 2; i &lt;= n; i ++) &#123; linklist * body = (linklist*)malloc(sizeof(linklist)); /* creat and init single node */ body -&gt; data = i; body -&gt; next = NULL; /* connect the single nodes together */ tmp -&gt; next = body; tmp = tmp -&gt; next; &#125; //printf("%d\n", tmp-&gt;data); /* now tmp is just the last node */ tmp -&gt; next = head; /*connect the head and the rear */ return head; /* by this method, we created a loop linklist */&#125;void yusefu(linklist * head,int k,int m)&#123; linklist * tail = head; //找到链表第一个结点的上一个结点，为删除操作做准备 while (tail -&gt; next != head) &#123; tail = tail -&gt; next; &#125; linklist * p = head; //找到编号为k的人(或者是第几个开始，可以改) while (p -&gt; data != k) &#123; tail = p; p = p-&gt;next; &#125; //从编号为k的人开始，只有符合p-&gt;next==p时，说明链表中除了p结点，所有编号都出列了， while (p -&gt; next != p) &#123; //找到从p报数1开始，报m的人，并且还要知道数m-1de人的位置tail，方便做删除操作。 for (int i = 1; i &lt; m; i ++) &#123; tail = p; p = p -&gt; next; &#125; tail-&gt;next=p-&gt;next;//从链表上将p结点去除 printf("%d \t",p -&gt; data); free(p); p = tail -&gt; next;//继续使用p指针指向出列编号的下一个编号 &#125; /* the last one */ printf("%d \n",p -&gt; data); free(p);&#125;int main() &#123; linklist * head=initLink(10); yusefu(head, 2, 5); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>约瑟夫问题</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之逆波兰式]]></title>
    <url>%2F2019%2F08%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[学的数据结构，感觉掌握的不牢固，于是实现了一个demo 中缀表达式转换为后缀表达式并求值 算法思想:创建一个操作数栈，自左向右遍历后缀表达式，遇到一个操作数就入栈，遇到一个操作符就从栈中取出两个操作数进行当前计算，载把结果入栈，直到表达式末尾, 最后一个入栈的就是最终结果 先实现求值这一步吧，已知后缀表达式 转换这一环节待更新… 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define maxsize 100#define datatype inttypedef struct &#123; datatype data[maxsize]; int top; // top 指明当前栈顶元素的位置&#125; SeqStack, *PSeqStack;// 初始化顺序栈PSeqStack Init_SeqStack()&#123; PSeqStack S; S = (PSeqStack) malloc(sizeof(SeqStack)); //printf("%p\n", S); if (S) S -&gt; top = -1; // top 设为-1 (认为设定),表示空 return S; // 返回指向顺序栈的指针&#125;// 判断栈空int Empty_SeqStack(PSeqStack S)&#123; // 没有元素，空栈 if (S -&gt; top == -1) return 1; // 1 表示为空 return 0; &#125;// 入栈void Push_SeqStack(PSeqStack S, datatype x)&#123; if (S -&gt; top == maxsize-1)&#123; printf("栈满不能再入栈\n"); //return 0; // 返回 0 表示失败 &#125; else&#123; S -&gt; top ++; S -&gt; data[S -&gt; top] = x; //return 1; &#125;&#125;// 出栈,保存栈顶元素于*x中，并删除void Pop_SeqStack(PSeqStack S, datatype *x)&#123; if (Empty_SeqStack(S))&#123; printf("栈空不能出栈\n"); //return 0; // 0 表示出栈失败 &#125; else&#123; *x = S -&gt; data[S -&gt; top]; S -&gt; top --; //return 1; &#125;&#125;// 取栈顶元素，只是获取他的值并存入*x，并没有取出来(删除),注意区别int GetTop_SeqStack(PSeqStack S, datatype *x)&#123; if (Empty_SeqStack(S))&#123; printf("栈空不能取top元素\n"); return 0; &#125; else&#123; *x = S -&gt; data[S -&gt; top]; return 1; &#125;&#125;// 销毁栈，参数为待销毁顺序栈的指针地址void Destory_SeqStack(PSeqStack *S)&#123; // *S 二级指针 if (*S) free (*S); *S = NULL; return;&#125;/* 判断是否是操作数 */int IsNum(char c)&#123; if (c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; return 1; &#125; return 0;&#125;char transfer()&#123; &#125;/* 核心函数 */int calculate(char *A)&#123; PSeqStack s = Init_SeqStack(); int result; int a, b, c; // a,b 上一次，上上一次入栈的元素，Ｃ是临时变量 char ch; ch = *A ++; /* 我们人为设置，在字符数组末尾加一个'#', 作为结束符 */ while(ch != '#')&#123; if (IsNum(ch))&#123; Push_SeqStack(s, ch - '0'); &#125; else &#123; /* 这里注意， 先进后出 */ Pop_SeqStack(s, &amp;b); Pop_SeqStack(s, &amp;a); switch (ch) &#123; case '+': c = a+b; break; case '-': c = a-b; break; case '*': c = a*b; break; case '/': c = a/b; break; default: break; &#125; /* 临时结果入栈 */ Push_SeqStack(s, c); &#125; ch = *A ++; &#125; GetTop_SeqStack(s, &amp;result); Destory_SeqStack(&amp;s); return result;&#125;int main()&#123; char num[12] = &#123;'1','2','8','5','-','*','+','4','2','/','-', '#'&#125;; printf("计算结果: %d\n",calculate(num)); return 0;&#125; 测试输入: 1char num[12] = &#123;'1','2','8','5','-','*','+','4','2','/','-', '#'&#125;; 测试结果: 15 写在最后其实，习惯了用C++的STL容器，我在平时的coding中很少会自己去创建一些数据结构，要排序会有std::sort()函数，而且STL容器的算法复杂度要远比单一数据结构算法复杂度要小的多，就拿排序来说，他用的可不止一种排序算法，不信这个有时间咱们可以验证…我学数据结构最大的收获就是： 学会用计算机的思维去思考问题 学会如何调试程序 学会耐心做一件事课程设计]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>逆波兰式</tag>
        <tag>堆栈</tag>
        <tag>中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统下文件乱码问题解决]]></title>
    <url>%2F2019%2F08%2F17%2FLinux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%96%87%E4%BB%B6%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3-1%2F</url>
    <content type="text"><![CDATA[今天在github上clone了一个master，想拿来练手，无奈是Windows下的编码，中文乱码，英文OK。于是想到之前看过一篇帖子，记录如下。 主要是用到了Linux的 iconv 命令 Step one 获取当前文件编码我当前文件是 Student.cpp 1file Student.cpp 得到输出如下： 1Student.cpp: C source, UTF-8 Unicode text 是个万国码 Step Two 获取本机编码1cat /etc/sysconfig/i18n 不知道为什么我这里报错，没有这个文件???不过Linux一般都是UTF-8 Step Three 修改文件编码1iconv -f GBK -t UTF-8 Student.cpp -o Student0.cpp 这里Student.cpp是原来的文件，Student0.cpp是我修改后的文件。 改后打开文件就没有乱码问题了 这里有个问题，如果有多个文件不能在一起转化比如我有两个文件，Student.cpp 和 Student.h 必须要执行两次命令，尴尬。后来想起来可以用通配符，文件名不改变，即可 注意： 通配符要慎用! 最后的最后: 写了个小项目，放在了仓库中编码转换]]></content>
      <categories>
        <category>utils</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>编码</tag>
        <tag>shell</tag>
      </tags>
  </entry>
</search>
